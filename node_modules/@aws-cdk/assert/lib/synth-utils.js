"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@aws-cdk/core");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs");
const path = require("path");
class SynthUtils {
    static synthesize(stack, options = {}) {
        // always synthesize against the root (be it an App or whatever) so all artifacts will be included
        const root = stack.node.root;
        // if the root is an app, invoke "synth" to avoid double synthesis
        const assembly = root instanceof core_1.App ? root.synth() : core_1.ConstructNode.synth(root.node, options);
        return assembly.getStackArtifact(stack.artifactId);
    }
    /**
     * Synthesizes the stack and returns the resulting CloudFormation template.
     */
    static toCloudFormation(stack, options = {}) {
        const synth = this._synthesizeWithNested(stack, options);
        if (synth instanceof cxapi.CloudFormationStackArtifact) {
            return synth.template;
        }
        else {
            return synth;
        }
    }
    /**
     * @returns Returns a subset of the synthesized CloudFormation template (only specific resource types).
     */
    static subset(stack, options) {
        const template = this.toCloudFormation(stack);
        if (template.Resources) {
            for (const [key, resource] of Object.entries(template.Resources)) {
                if (options.resourceTypes && !options.resourceTypes.includes(resource.Type)) {
                    delete template.Resources[key];
                }
            }
        }
        return template;
    }
    /**
     * Synthesizes the stack and returns a `CloudFormationStackArtifact` which can be inspected.
     * Supports nested stacks as well as normal stacks.
     *
     * @return CloudFormationStackArtifact for normal stacks or the actual template for nested stacks
     * @internal
     */
    static _synthesizeWithNested(stack, options = {}) {
        // always synthesize against the root (be it an App or whatever) so all artifacts will be included
        const root = stack.node.root;
        // if the root is an app, invoke "synth" to avoid double synthesis
        const assembly = root instanceof core_1.App ? root.synth() : core_1.ConstructNode.synth(root.node, options);
        // if this is a nested stack (it has a parent), then just read the template as a string
        if (stack.parentStack) {
            return JSON.parse(fs.readFileSync(path.join(assembly.directory, stack.templateFile)).toString('utf-8'));
        }
        return assembly.getStackArtifact(stack.artifactId);
    }
}
exports.SynthUtils = SynthUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ludGgtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzeW50aC11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdDQUE0RTtBQUM1RSx5Q0FBMEM7QUFDMUMseUJBQTBCO0FBQzFCLDZCQUE4QjtBQUU5QixNQUFhLFVBQVU7SUFDZCxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQVksRUFBRSxVQUE0QixFQUFHO1FBQ3BFLGtHQUFrRztRQUNsRyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztRQUU3QixrRUFBa0U7UUFDbEUsTUFBTSxRQUFRLEdBQUcsSUFBSSxZQUFZLFVBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxvQkFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRTlGLE9BQU8sUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsS0FBWSxFQUFFLFVBQTRCLEVBQUc7UUFDMUUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN6RCxJQUFJLEtBQUssWUFBWSxLQUFLLENBQUMsMkJBQTJCLEVBQUU7WUFDdEQsT0FBTyxLQUFLLENBQUMsUUFBUSxDQUFDO1NBQ3ZCO2FBQU07WUFDTCxPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFZLEVBQUUsT0FBc0I7UUFDdkQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUN0QixLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ2hFLElBQUksT0FBTyxDQUFDLGFBQWEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFFLFFBQWdCLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3BGLE9BQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDaEM7YUFDRjtTQUNGO1FBRUQsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxLQUFZLEVBQUUsVUFBNEIsRUFBRztRQUMvRSxrR0FBa0c7UUFDbEcsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFN0Isa0VBQWtFO1FBQ2xFLE1BQU0sUUFBUSxHQUFHLElBQUksWUFBWSxVQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsb0JBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUU5Rix1RkFBdUY7UUFDdkYsSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUN6RztRQUVELE9BQU8sUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyRCxDQUFDO0NBQ0Y7QUE1REQsZ0NBNERDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwLCBDb25zdHJ1Y3ROb2RlLCBTdGFjaywgU3ludGhlc2lzT3B0aW9ucyB9IGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgZnMgPSByZXF1aXJlKCdmcycpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmV4cG9ydCBjbGFzcyBTeW50aFV0aWxzIHtcbiAgcHVibGljIHN0YXRpYyBzeW50aGVzaXplKHN0YWNrOiBTdGFjaywgb3B0aW9uczogU3ludGhlc2lzT3B0aW9ucyA9IHsgfSk6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCB7XG4gICAgLy8gYWx3YXlzIHN5bnRoZXNpemUgYWdhaW5zdCB0aGUgcm9vdCAoYmUgaXQgYW4gQXBwIG9yIHdoYXRldmVyKSBzbyBhbGwgYXJ0aWZhY3RzIHdpbGwgYmUgaW5jbHVkZWRcbiAgICBjb25zdCByb290ID0gc3RhY2subm9kZS5yb290O1xuXG4gICAgLy8gaWYgdGhlIHJvb3QgaXMgYW4gYXBwLCBpbnZva2UgXCJzeW50aFwiIHRvIGF2b2lkIGRvdWJsZSBzeW50aGVzaXNcbiAgICBjb25zdCBhc3NlbWJseSA9IHJvb3QgaW5zdGFuY2VvZiBBcHAgPyByb290LnN5bnRoKCkgOiBDb25zdHJ1Y3ROb2RlLnN5bnRoKHJvb3Qubm9kZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gYXNzZW1ibHkuZ2V0U3RhY2tBcnRpZmFjdChzdGFjay5hcnRpZmFjdElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplcyB0aGUgc3RhY2sgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdG9DbG91ZEZvcm1hdGlvbihzdGFjazogU3RhY2ssIG9wdGlvbnM6IFN5bnRoZXNpc09wdGlvbnMgPSB7IH0pOiBhbnkge1xuICAgIGNvbnN0IHN5bnRoID0gdGhpcy5fc3ludGhlc2l6ZVdpdGhOZXN0ZWQoc3RhY2ssIG9wdGlvbnMpO1xuICAgIGlmIChzeW50aCBpbnN0YW5jZW9mIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCkge1xuICAgICAgcmV0dXJuIHN5bnRoLnRlbXBsYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3ludGg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFJldHVybnMgYSBzdWJzZXQgb2YgdGhlIHN5bnRoZXNpemVkIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIChvbmx5IHNwZWNpZmljIHJlc291cmNlIHR5cGVzKS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc3Vic2V0KHN0YWNrOiBTdGFjaywgb3B0aW9uczogU3Vic2V0T3B0aW9ucyk6IGFueSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnRvQ2xvdWRGb3JtYXRpb24oc3RhY2spO1xuICAgIGlmICh0ZW1wbGF0ZS5SZXNvdXJjZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgcmVzb3VyY2VdIG9mIE9iamVjdC5lbnRyaWVzKHRlbXBsYXRlLlJlc291cmNlcykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzb3VyY2VUeXBlcyAmJiAhb3B0aW9ucy5yZXNvdXJjZVR5cGVzLmluY2x1ZGVzKChyZXNvdXJjZSBhcyBhbnkpLlR5cGUpKSB7XG4gICAgICAgICAgZGVsZXRlIHRlbXBsYXRlLlJlc291cmNlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bnRoZXNpemVzIHRoZSBzdGFjayBhbmQgcmV0dXJucyBhIGBDbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RgIHdoaWNoIGNhbiBiZSBpbnNwZWN0ZWQuXG4gICAqIFN1cHBvcnRzIG5lc3RlZCBzdGFja3MgYXMgd2VsbCBhcyBub3JtYWwgc3RhY2tzLlxuICAgKlxuICAgKiBAcmV0dXJuIENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCBmb3Igbm9ybWFsIHN0YWNrcyBvciB0aGUgYWN0dWFsIHRlbXBsYXRlIGZvciBuZXN0ZWQgc3RhY2tzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBfc3ludGhlc2l6ZVdpdGhOZXN0ZWQoc3RhY2s6IFN0YWNrLCBvcHRpb25zOiBTeW50aGVzaXNPcHRpb25zID0geyB9KTogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IHwgb2JqZWN0IHtcbiAgICAvLyBhbHdheXMgc3ludGhlc2l6ZSBhZ2FpbnN0IHRoZSByb290IChiZSBpdCBhbiBBcHAgb3Igd2hhdGV2ZXIpIHNvIGFsbCBhcnRpZmFjdHMgd2lsbCBiZSBpbmNsdWRlZFxuICAgIGNvbnN0IHJvb3QgPSBzdGFjay5ub2RlLnJvb3Q7XG5cbiAgICAvLyBpZiB0aGUgcm9vdCBpcyBhbiBhcHAsIGludm9rZSBcInN5bnRoXCIgdG8gYXZvaWQgZG91YmxlIHN5bnRoZXNpc1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gcm9vdCBpbnN0YW5jZW9mIEFwcCA/IHJvb3Quc3ludGgoKSA6IENvbnN0cnVjdE5vZGUuc3ludGgocm9vdC5ub2RlLCBvcHRpb25zKTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBuZXN0ZWQgc3RhY2sgKGl0IGhhcyBhIHBhcmVudCksIHRoZW4ganVzdCByZWFkIHRoZSB0ZW1wbGF0ZSBhcyBhIHN0cmluZ1xuICAgIGlmIChzdGFjay5wYXJlbnRTdGFjaykge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihhc3NlbWJseS5kaXJlY3RvcnksIHN0YWNrLnRlbXBsYXRlRmlsZSkpLnRvU3RyaW5nKCd1dGYtOCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzZW1ibHkuZ2V0U3RhY2tBcnRpZmFjdChzdGFjay5hcnRpZmFjdElkKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNldE9wdGlvbnMge1xuICAvKipcbiAgICogTWF0Y2ggYWxsIHJlc291cmNlcyBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgKi9cbiAgcmVzb3VyY2VUeXBlcz86IHN0cmluZ1tdO1xufVxuIl19