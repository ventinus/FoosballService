"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
/**
 * Collection of file-system utility methods
 */
class FsUtils {
    /**
     * Generates a filesystem structure from a string,
     * formatted like the output of a `tree` shell command
     *
     * @param tmpPrefix temp directory prefix, used by {@link fs.mkdtemp}
     * @param tree
     * @param content the content
     *
     * @returns an array containing the absolute path of the created directory,
     *          and a cleanup function that will remove the generated files on invocation
     */
    static fromTree(tmpPrefix, tree, content = 'content') {
        const directory = fs.mkdtempSync(path.join(os.tmpdir(), tmpPrefix));
        const directories = [];
        const files = [];
        const symlinks = [];
        // we push an element at the end because we push the files/directories during the previous iteration
        const lines = [...tree.replace(/^\n+/, '').trimRight().split('\n'), ''];
        const initialIndentLevel = (lines[0].match(/^\s*/) || [''])[0].length;
        lines.reduce(([previousDir, previousIndentLevel, wasDirectory], line) => {
            const indentCharacters = (line.match(FsUtils.INDENT_CHARACTERS_REGEX) || [''])[0];
            const indentLevel = (indentCharacters.length - initialIndentLevel) / 4;
            const fileName = line.slice(indentCharacters.length).replace(FsUtils.TRAILING_CHARACTERS_REGEX, '').trimRight();
            const current = indentLevel <= previousIndentLevel ?
                path.join(...previousDir.split(path.sep).slice(0, indentLevel - 1), fileName) :
                path.join(previousDir, fileName);
            if (previousDir) {
                // Because of the structure of a tree output, we need the next line
                // to tell whether the current one is a directory or not.
                // If the indentation as increased (or it was forcefully marked as a directory by ending with "(D)")
                // then we know the previous file is a directory
                if (indentLevel > previousIndentLevel || wasDirectory) {
                    directories.push(previousDir);
                }
                else if (FsUtils.SYMBOLIC_LINK_REGEX.test(previousDir)) {
                    const [link, target] = previousDir.split(FsUtils.SYMBOLIC_LINK_REGEX);
                    symlinks.push([link, target]);
                }
                else {
                    files.push(previousDir);
                }
            }
            return [current, indentLevel, FsUtils.IS_DIRECTORY_REGEX.test(line)];
        }, ['', 0, false]);
        // we create the directories first, as they're needed to store the files
        for (const _directory of directories) {
            fs.mkdirSync(path.join(directory, _directory));
        }
        // we create the files first, as they're needed to create the symlinks
        for (const file of files) {
            fs.writeFileSync(path.join(directory, file), content);
        }
        for (const [link, target] of symlinks) {
            fs.symlinkSync(target, path.join(directory, link));
        }
        return {
            directory,
            cleanup: () => {
                // reverse order of the creation, we need to empty the directories before rmdir
                for (const [link] of symlinks) {
                    fs.unlinkSync(path.join(directory, link));
                }
                for (const file of files) {
                    fs.unlinkSync(path.join(directory, file));
                }
                for (const _directory of directories.reverse()) {
                    fs.rmdirSync(path.join(directory, _directory));
                }
                // finally, we delete the directory created by mkdtempSync
                fs.rmdirSync(directory);
            }
        };
    }
}
exports.FsUtils = FsUtils;
/**
 * RegExp matching characters used to indent the tree, indicating the line depth
 */
FsUtils.INDENT_CHARACTERS_REGEX = /^[\s├─│└]+/;
/**
 * RegExp matching characters trailing a tree line
 */
FsUtils.TRAILING_CHARACTERS_REGEX = /(\/|\(D\))$/i;
/**
 * RegExp determining whether a given line is an explicit directory
 */
FsUtils.IS_DIRECTORY_REGEX = /\(D\)\s*$/i;
/**
 * RegExp determining whether a given line is a symblic link
 */
FsUtils.SYMBOLIC_LINK_REGEX = /\s*[=-]>\s*/;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmcy11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlCQUEwQjtBQUMxQix5QkFBMEI7QUFDMUIsNkJBQThCO0FBYTlCOztHQUVHO0FBQ0gsTUFBYSxPQUFPO0lBQ2xCOzs7Ozs7Ozs7O09BVUc7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQWlCLEVBQUUsSUFBWSxFQUFFLE9BQU8sR0FBRyxTQUFTO1FBQ3pFLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUVwRSxNQUFNLFdBQVcsR0FBYSxFQUFFLENBQUM7UUFDakMsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO1FBQzNCLE1BQU0sUUFBUSxHQUE0QixFQUFFLENBQUM7UUFFN0Msb0dBQW9HO1FBQ3BHLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEUsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUV0RSxLQUFLLENBQUMsTUFBTSxDQUE0QixDQUFDLENBQUMsV0FBVyxFQUFFLG1CQUFtQixFQUFFLFlBQVksQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ2pHLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENB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TUFBTSxVQUFVLElBQUksV0FBVyxDQUFDLE9BQU8sRUFBRSxFQUFFO29CQUM5QyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7aUJBQ2hEO2dCQUVELDBEQUEwRDtnQkFDMUQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMxQixDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7O0FBakZILDBCQW9HQztBQWpCQzs7R0FFRztBQUNxQiwrQkFBdUIsR0FBRyxZQUFZLENBQUM7QUFDL0Q7O0dBRUc7QUFDcUIsaUNBQXlCLEdBQUcsY0FBYyxDQUFDO0FBQ25FOztHQUVHO0FBQ3FCLDBCQUFrQixHQUFHLFlBQVksQ0FBQztBQUMxRDs7R0FFRztBQUNxQiwyQkFBbUIsR0FBRyxhQUFhLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgPSByZXF1aXJlKCdmcycpO1xuaW1wb3J0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5pbnRlcmZhY2UgRnJvbVRyZWVPdXRwdXQge1xuICAvKipcbiAgICogQWJzb2x1dGUgcGF0aCBvZiB0aGUgY3JlYXRlZCB0ZW1wb3JhcnkgZGlyZWN0b3J5LCBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgc3RydWN0dXJlXG4gICAqL1xuICByZWFkb25seSBkaXJlY3Rvcnk6IHN0cmluZztcbiAgLyoqXG4gICAqIENsZWFudXAgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgZ2VuZXJhdGVkIGZpbGVzIG9uY2UgY2FsbGVkXG4gICAqL1xuICByZWFkb25seSBjbGVhbnVwOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgZmlsZS1zeXN0ZW0gdXRpbGl0eSBtZXRob2RzXG4gKi9cbmV4cG9ydCBjbGFzcyBGc1V0aWxzIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGZpbGVzeXN0ZW0gc3RydWN0dXJlIGZyb20gYSBzdHJpbmcsXG4gICAqIGZvcm1hdHRlZCBsaWtlIHRoZSBvdXRwdXQgb2YgYSBgdHJlZWAgc2hlbGwgY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0gdG1wUHJlZml4IHRlbXAgZGlyZWN0b3J5IHByZWZpeCwgdXNlZCBieSB7QGxpbmsgZnMubWtkdGVtcH1cbiAgICogQHBhcmFtIHRyZWVcbiAgICogQHBhcmFtIGNvbnRlbnQgdGhlIGNvbnRlbnRcbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgY3JlYXRlZCBkaXJlY3RvcnksXG4gICAqICAgICAgICAgIGFuZCBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgZ2VuZXJhdGVkIGZpbGVzIG9uIGludm9jYXRpb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVRyZWUodG1wUHJlZml4OiBzdHJpbmcsIHRyZWU6IHN0cmluZywgY29udGVudCA9ICdjb250ZW50Jyk6IEZyb21UcmVlT3V0cHV0IHtcbiAgICBjb25zdCBkaXJlY3RvcnkgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4ob3MudG1wZGlyKCksIHRtcFByZWZpeCkpO1xuXG4gICAgY29uc3QgZGlyZWN0b3JpZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgc3ltbGlua3M6IEFycmF5PFtzdHJpbmcsIHN0cmluZ10+ID0gW107XG5cbiAgICAvLyB3ZSBwdXNoIGFuIGVsZW1lbnQgYXQgdGhlIGVuZCBiZWNhdXNlIHdlIHB1c2ggdGhlIGZpbGVzL2RpcmVjdG9yaWVzIGR1cmluZyB0aGUgcHJldmlvdXMgaXRlcmF0aW9uXG4gICAgY29uc3QgbGluZXMgPSBbLi4udHJlZS5yZXBsYWNlKC9eXFxuKy8sICcnKS50cmltUmlnaHQoKS5zcGxpdCgnXFxuJyksICcnXTtcbiAgICBjb25zdCBpbml0aWFsSW5kZW50TGV2ZWwgPSAobGluZXNbMF0ubWF0Y2goL15cXHMqLykgfHwgWycnXSlbMF0ubGVuZ3RoO1xuXG4gICAgbGluZXMucmVkdWNlPFtzdHJpbmcsIG51bWJlciwgYm9vbGVhbl0+KChbcHJldmlvdXNEaXIsIHByZXZpb3VzSW5kZW50TGV2ZWwsIHdhc0RpcmVjdG9yeV0sIGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGluZGVudENoYXJhY3RlcnMgPSAobGluZS5tYXRjaChGc1V0aWxzLklOREVOVF9DSEFSQUNURVJTX1JFR0VYKSB8fCBbJyddKVswXTtcbiAgICAgIGNvbnN0IGluZGVudExldmVsID0gKGluZGVudENoYXJhY3RlcnMubGVuZ3RoIC0gaW5pdGlhbEluZGVudExldmVsKSAvIDQ7XG5cbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gbGluZS5zbGljZShpbmRlbnRDaGFyYWN0ZXJzLmxlbmd0aCkucmVwbGFjZShGc1V0aWxzLlRSQUlMSU5HX0NIQVJBQ1RFUlNfUkVHRVgsICcnKS50cmltUmlnaHQoKTtcblxuICAgICAgY29uc3QgY3VycmVudCA9IGluZGVudExldmVsIDw9IHByZXZpb3VzSW5kZW50TGV2ZWwgP1xuICAgICAgICBwYXRoLmpvaW4oLi4ucHJldmlvdXNEaXIuc3BsaXQocGF0aC5zZXApLnNsaWNlKDAsIGluZGVudExldmVsIC0gMSksIGZpbGVOYW1lKSA6XG4gICAgICAgIHBhdGguam9pbihwcmV2aW91c0RpciwgZmlsZU5hbWUpO1xuXG4gICAgICBpZiAocHJldmlvdXNEaXIpIHtcbiAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgc3RydWN0dXJlIG9mIGEgdHJlZSBvdXRwdXQsIHdlIG5lZWQgdGhlIG5leHQgbGluZVxuICAgICAgICAvLyB0byB0ZWxsIHdoZXRoZXIgdGhlIGN1cnJlbnQgb25lIGlzIGEgZGlyZWN0b3J5IG9yIG5vdC5cbiAgICAgICAgLy8gSWYgdGhlIGluZGVudGF0aW9uIGFzIGluY3JlYXNlZCAob3IgaXQgd2FzIGZvcmNlZnVsbHkgbWFya2VkIGFzIGEgZGlyZWN0b3J5IGJ5IGVuZGluZyB3aXRoIFwiKEQpXCIpXG4gICAgICAgIC8vIHRoZW4gd2Uga25vdyB0aGUgcHJldmlvdXMgZmlsZSBpcyBhIGRpcmVjdG9yeVxuICAgICAgICBpZiAoaW5kZW50TGV2ZWwgPiBwcmV2aW91c0luZGVudExldmVsIHx8IHdhc0RpcmVjdG9yeSkge1xuICAgICAgICAgIGRpcmVjdG9yaWVzLnB1c2gocHJldmlvdXNEaXIpO1xuICAgICAgICB9IGVsc2UgaWYgKEZzVXRpbHMuU1lNQk9MSUNfTElOS19SRUdFWC50ZXN0KHByZXZpb3VzRGlyKSkge1xuICAgICAgICAgIGNvbnN0IFtsaW5rLCB0YXJnZXRdID0gcHJldmlvdXNEaXIuc3BsaXQoRnNVdGlscy5TWU1CT0xJQ19MSU5LX1JFR0VYKTtcbiAgICAgICAgICBzeW1saW5rcy5wdXNoKFtsaW5rLCB0YXJnZXRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxlcy5wdXNoKHByZXZpb3VzRGlyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2N1cnJlbnQsIGluZGVudExldmVsLCBGc1V0aWxzLklTX0RJUkVDVE9SWV9SRUdFWC50ZXN0KGxpbmUpXTtcbiAgICB9LCBbJycsIDAsIGZhbHNlXSk7XG5cbiAgICAvLyB3ZSBjcmVhdGUgdGhlIGRpcmVjdG9yaWVzIGZpcnN0LCBhcyB0aGV5J3JlIG5lZWRlZCB0byBzdG9yZSB0aGUgZmlsZXNcbiAgICBmb3IgKGNvbnN0IF9kaXJlY3Rvcnkgb2YgZGlyZWN0b3JpZXMpIHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmpvaW4oZGlyZWN0b3J5LCBfZGlyZWN0b3J5KSk7XG4gICAgfVxuICAgIC8vIHdlIGNyZWF0ZSB0aGUgZmlsZXMgZmlyc3QsIGFzIHRoZXkncmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgc3ltbGlua3NcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGRpcmVjdG9yeSwgZmlsZSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtsaW5rLCB0YXJnZXRdIG9mIHN5bWxpbmtzKSB7XG4gICAgICBmcy5zeW1saW5rU3luYyh0YXJnZXQsIHBhdGguam9pbihkaXJlY3RvcnksIGxpbmspKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0b3J5LFxuICAgICAgY2xlYW51cDogKCkgPT4ge1xuICAgICAgICAvLyByZXZlcnNlIG9yZGVyIG9mIHRoZSBjcmVhdGlvbiwgd2UgbmVlZCB0byBlbXB0eSB0aGUgZGlyZWN0b3JpZXMgYmVmb3JlIHJtZGlyXG4gICAgICAgIGZvciAoY29uc3QgW2xpbmtdIG9mIHN5bWxpbmtzKSB7XG4gICAgICAgICAgZnMudW5saW5rU3luYyhwYXRoLmpvaW4oZGlyZWN0b3J5LCBsaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgZnMudW5saW5rU3luYyhwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBfZGlyZWN0b3J5IG9mIGRpcmVjdG9yaWVzLnJldmVyc2UoKSkge1xuICAgICAgICAgIGZzLnJtZGlyU3luYyhwYXRoLmpvaW4oZGlyZWN0b3J5LCBfZGlyZWN0b3J5KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5LCB3ZSBkZWxldGUgdGhlIGRpcmVjdG9yeSBjcmVhdGVkIGJ5IG1rZHRlbXBTeW5jXG4gICAgICAgIGZzLnJtZGlyU3luYyhkaXJlY3RvcnkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVnRXhwIG1hdGNoaW5nIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgdGhlIHRyZWUsIGluZGljYXRpbmcgdGhlIGxpbmUgZGVwdGhcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IElOREVOVF9DSEFSQUNURVJTX1JFR0VYID0gL15bXFxz4pSc4pSA4pSC4pSUXSsvO1xuICAvKipcbiAgICogUmVnRXhwIG1hdGNoaW5nIGNoYXJhY3RlcnMgdHJhaWxpbmcgYSB0cmVlIGxpbmVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFRSQUlMSU5HX0NIQVJBQ1RFUlNfUkVHRVggPSAvKFxcL3xcXChEXFwpKSQvaTtcbiAgLyoqXG4gICAqIFJlZ0V4cCBkZXRlcm1pbmluZyB3aGV0aGVyIGEgZ2l2ZW4gbGluZSBpcyBhbiBleHBsaWNpdCBkaXJlY3RvcnlcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IElTX0RJUkVDVE9SWV9SRUdFWCA9IC9cXChEXFwpXFxzKiQvaTtcbiAgLyoqXG4gICAqIFJlZ0V4cCBkZXRlcm1pbmluZyB3aGV0aGVyIGEgZ2l2ZW4gbGluZSBpcyBhIHN5bWJsaWMgbGlua1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU1lNQk9MSUNfTElOS19SRUdFWCA9IC9cXHMqWz0tXT5cXHMqLztcblxufSJdfQ==