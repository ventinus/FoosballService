"use strict";
// Slightly refactored version of fs-extra mkdirpSync
// https://github.com/jprichardson/node-fs-extra/blob/d1a01e735e81688e08688557d7a254fa8297d98e/lib/mkdirs/mkdirs.js
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const INVALID_PATH_CHARS = /[<>:"|?*]/;
const o777 = parseInt('0777', 8);
function getRootPath(p) {
    const paths = path.normalize(path.resolve(p)).split(path.sep);
    if (paths.length > 0) {
        return paths[0];
    }
    return null;
}
function invalidWin32Path(p) {
    const rp = getRootPath(p);
    p = p.replace(rp || '', '');
    return INVALID_PATH_CHARS.test(p);
}
function mkdirpSync(p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    let mode = opts.mode;
    const xfs = opts.fs || fs;
    if (process.platform === 'win32' && invalidWin32Path(p)) {
        const errInval = new Error(p + ' contains invalid WIN32 path characters.');
        // @ts-ignore
        errInval.code = 'EINVAL';
        throw errInval;
    }
    if (mode === undefined) {
        // tslint:disable-next-line: no-bitwise
        mode = o777 & (~process.umask());
    }
    if (!made) {
        made = null;
    }
    p = path.resolve(p);
    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        if (err0.code === 'ENOENT') {
            if (path.dirname(p) === p) {
                throw err0;
            }
            made = mkdirpSync(path.dirname(p), opts, made);
            mkdirpSync(p, opts, made);
        }
        else {
            // In the case of any other error, just see if there's a dir there
            // already. If so, then hooray!  If not, then something is borked.
            let stat;
            try {
                stat = xfs.statSync(p);
            }
            catch (err1) {
                throw err0;
            }
            if (!stat.isDirectory()) {
                throw err0;
            }
        }
    }
    return made;
}
exports.mkdirpSync = mkdirpSync;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWtkaXJwU3luYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1rZGlycFN5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHFEQUFxRDtBQUNyRCxtSEFBbUg7O0FBRW5ILHlCQUEwQjtBQUMxQiw2QkFBOEI7QUFFOUIsTUFBTSxrQkFBa0IsR0FBRyxXQUFXLENBQUM7QUFDdkMsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztBQUVqQyxTQUFTLFdBQVcsQ0FBQyxDQUFTO0lBQzFCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUQsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUFFLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQUU7SUFDMUMsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsQ0FBUztJQUMvQixNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1QixPQUFPLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QyxDQUFDO0FBRUQsU0FBZ0IsVUFBVSxDQUFDLENBQVMsRUFBRSxJQUFVLEVBQUUsSUFBVTtJQUN4RCxJQUFJLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtRQUNuQyxJQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7S0FDekI7SUFFRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO0lBRTFCLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLElBQUksZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDckQsTUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLDBDQUEwQyxDQUFDLENBQUM7UUFDM0UsYUFBYTtRQUNiLFFBQVEsQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLE1BQU0sUUFBUSxDQUFDO0tBQ2xCO0lBRUQsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1FBQ3BCLHVDQUF1QztRQUN2QyxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUNwQztJQUNELElBQUksQ0FBQyxJQUFJLEVBQUU7UUFBRSxJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQUU7SUFFM0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFcEIsSUFBSTtRQUNBLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDO0tBQ3BCO0lBQUMsT0FBTyxJQUFJLEVBQUU7UUFDWCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQ3hCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQUUsTUFBTSxJQUFJLENBQUM7YUFBRTtZQUMxQyxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQy9DLFVBQVUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzdCO2FBQU07WUFDSCxrRUFBa0U7WUFDbEUsa0VBQWtFO1lBQ2xFLElBQUksSUFBSSxDQUFDO1lBQ1QsSUFBSTtnQkFDQSxJQUFJLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQjtZQUFDLE9BQU8sSUFBSSxFQUFFO2dCQUNYLE1BQU0sSUFBSSxDQUFDO2FBQ2Q7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO2dCQUFFLE1BQU0sSUFBSSxDQUFDO2FBQUU7U0FDM0M7S0FDSjtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUE3Q0QsZ0NBNkNDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gU2xpZ2h0bHkgcmVmYWN0b3JlZCB2ZXJzaW9uIG9mIGZzLWV4dHJhIG1rZGlycFN5bmNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9ibG9iL2QxYTAxZTczNWU4MTY4OGUwODY4ODU1N2Q3YTI1NGZhODI5N2Q5OGUvbGliL21rZGlycy9ta2RpcnMuanNcblxuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBJTlZBTElEX1BBVEhfQ0hBUlMgPSAvWzw+OlwifD8qXS87XG5jb25zdCBvNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxuZnVuY3Rpb24gZ2V0Um9vdFBhdGgocDogc3RyaW5nKSB7XG4gICAgY29uc3QgcGF0aHMgPSBwYXRoLm5vcm1hbGl6ZShwYXRoLnJlc29sdmUocCkpLnNwbGl0KHBhdGguc2VwKTtcbiAgICBpZiAocGF0aHMubGVuZ3RoID4gMCkgeyByZXR1cm4gcGF0aHNbMF07IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW52YWxpZFdpbjMyUGF0aChwOiBzdHJpbmcpIHtcbiAgICBjb25zdCBycCA9IGdldFJvb3RQYXRoKHApO1xuICAgIHAgPSBwLnJlcGxhY2UocnAgfHwgJycsICcnKTtcbiAgICByZXR1cm4gSU5WQUxJRF9QQVRIX0NIQVJTLnRlc3QocCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBta2RpcnBTeW5jKHA6IHN0cmluZywgb3B0cz86IGFueSwgbWFkZT86IGFueSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xuICAgIH1cblxuICAgIGxldCBtb2RlID0gb3B0cy5tb2RlO1xuICAgIGNvbnN0IHhmcyA9IG9wdHMuZnMgfHwgZnM7XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiBpbnZhbGlkV2luMzJQYXRoKHApKSB7XG4gICAgICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVyckludmFsLmNvZGUgPSAnRUlOVkFMJztcbiAgICAgICAgdGhyb3cgZXJySW52YWw7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWJpdHdpc2VcbiAgICAgICAgbW9kZSA9IG83NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XG4gICAgfVxuICAgIGlmICghbWFkZSkgeyBtYWRlID0gbnVsbDsgfVxuXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHhmcy5ta2RpclN5bmMocCwgbW9kZSk7XG4gICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgfSBjYXRjaCAoZXJyMCkge1xuICAgICAgICBpZiAoZXJyMC5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgaWYgKHBhdGguZGlybmFtZShwKSA9PT0gcCkgeyB0aHJvdyBlcnIwOyB9XG4gICAgICAgICAgICBtYWRlID0gbWtkaXJwU3luYyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIG1hZGUpO1xuICAgICAgICAgICAgbWtkaXJwU3luYyhwLCBvcHRzLCBtYWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpciB0aGVyZVxuICAgICAgICAgICAgLy8gYWxyZWFkeS4gSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZyBpcyBib3JrZWQuXG4gICAgICAgICAgICBsZXQgc3RhdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHsgdGhyb3cgZXJyMDsgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hZGU7XG59Il19