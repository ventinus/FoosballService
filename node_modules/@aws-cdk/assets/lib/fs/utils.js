"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const minimatch = require("minimatch");
const path = require("path");
const follow_mode_1 = require("./follow-mode");
/**
 * Determines whether a given file should be excluded or not based on given
 * exclusion glob patterns.
 *
 * @param exclude  exclusion patterns
 * @param filePath file path to be assessed against the pattern
 *
 * @returns `true` if the file should be excluded
 *
 * @deprecated see {@link ExcludeRules.excludeFile}
 */
function shouldExclude(exclude, filePath) {
    const [_shouldExclude] = ExcludeRules.evaluateFile(exclude, filePath);
    return _shouldExclude;
}
exports.shouldExclude = shouldExclude;
/**
 * Set of exclusion evaluation methods
 */
class ExcludeRules {
    constructor(patterns) {
        this.patterns = patterns;
        this.patternComponents = this.patterns.map(ExcludeRules.getPathComponents);
    }
    /**
     * Determines whether a given file should be excluded or not based on given
     * exclusion glob patterns.
     *
     * @param patterns  exclusion patterns
     * @param filePath file path to be assessed against the pattern
     *
     * @returns `true` if the file should be excluded, followed by the index of the rule applied
     */
    static evaluateFile(patterns, filePath) {
        let _shouldExclude = false;
        let exclusionIndex = -1;
        patterns.map((pattern, patternIndex) => {
            if (minimatch(filePath, pattern, { matchBase: true, flipNegate: true })) {
                [_shouldExclude, exclusionIndex] = [!pattern.startsWith('!'), patternIndex];
            }
        });
        return [_shouldExclude, exclusionIndex];
    }
    /**
     * Splits a file or directory path in an array of elements
     * containing each partial path up to that point
     *
     * @param filePath the path to split
     * @returns an array containing each path component
     *
     * @example ExcludeRules.getAccumulatedPathComponents('a/b/c') = ['a', 'a/b', 'a/b/c']
     */
    static getAccumulatedPathComponents(filePath) {
        const accComponents = [];
        for (const component of ExcludeRules.getPathComponents(filePath)) {
            accComponents.push(accComponents.length ?
                [accComponents[accComponents.length - 1], component].join(path.sep) :
                component);
        }
        return accComponents;
    }
    get accumulatedPatternComponents() {
        const patternComponentsLength = this.patternComponents.map(({ length }) => length);
        const maxPatternLength = Math.max(...patternComponentsLength);
        const accPatternComponents = [];
        for (let pattenComponentsLength = 1; pattenComponentsLength <= maxPatternLength; ++pattenComponentsLength) {
            accPatternComponents.push(this.patternComponents.map((pattern) => pattern.slice(0, pattenComponentsLength).join(path.sep)));
        }
        return accPatternComponents;
    }
    /**
     * Determines whether a given file should be excluded,taking into account deep file structures
     *
     * @param filePath file path to be assessed against the pattern
     */
    excludeFile(relativePath) {
        let accExclude = false;
        let accPriority = -1;
        for (const accPath of ExcludeRules.getAccumulatedPathComponents(relativePath)) {
            const [shouldExcludeIt, priorityIt] = ExcludeRules.evaluateFile(this.patterns, accPath);
            if (priorityIt > accPriority) {
                [accExclude, accPriority] = [shouldExcludeIt, priorityIt];
            }
        }
        return accExclude;
    }
    /**
     * Determines whether a given directory should be excluded and not explored further
     * This might be `true` even if the directory is explicitly excluded,
     * but one of its children might be inclunded
     *
     * @param directoryPath directory path to be assessed against the pattern
     */
    excludeDirectory(directoryPath) {
        let _shouldExclude = null;
        for (const accPath of ExcludeRules.getAccumulatedPathComponents(directoryPath)) {
            this.accumulatedPatternComponents.map((accumulatedPatterns, accumulatedIndex) => {
                const [shouldExcludeIt, patternIndex] = ExcludeRules.evaluateFile(accumulatedPatterns, accPath);
                if (patternIndex < 0) {
                    return;
                }
                if (shouldExcludeIt) {
                    if (_shouldExclude === null) {
                        _shouldExclude = true;
                    }
                }
                else if (accumulatedIndex < this.patternComponents[patternIndex].length - 1) {
                    _shouldExclude = shouldExcludeIt;
                }
                else if (!accumulatedPatterns[patternIndex].includes('**')) {
                    _shouldExclude = true;
                }
            });
        }
        return _shouldExclude || false;
    }
}
exports.ExcludeRules = ExcludeRules;
/**
 * Splits a file or directory path in an array of elements
 * containing each path component (directories and file)
 *
 * @param filePath the path to split
 * @returns an array containing each path component
 *
 * @example ExcludeRules.getPathComponents('a/b/c') = ['a', 'b', 'c']
 */
ExcludeRules.getPathComponents = (filePath) => filePath.split(path.sep);
/**
 * Determines whether a symlink should be followed or not, based on a FollowMode.
 *
 * @param mode       the FollowMode.
 * @param sourceRoot the root of the source tree.
 * @param realPath   the real path of the target of the symlink.
 *
 * @returns true if the link should be followed.
 */
function shouldFollow(mode, sourceRoot, realPath) {
    switch (mode) {
        case follow_mode_1.FollowMode.ALWAYS:
            return fs.existsSync(realPath);
        case follow_mode_1.FollowMode.EXTERNAL:
            return !_isInternal() && fs.existsSync(realPath);
        case follow_mode_1.FollowMode.BLOCK_EXTERNAL:
            return _isInternal() && fs.existsSync(realPath);
        case follow_mode_1.FollowMode.NEVER:
            return false;
        default:
            throw new Error(`Unsupported FollowMode: ${mode}`);
    }
    function _isInternal() {
        return path.resolve(realPath).startsWith(path.resolve(sourceRoot));
    }
}
exports.shouldFollow = shouldFollow;
const generateAssetFile = (rootDir, fullFilePath, stat) => ({
    absolutePath: fullFilePath,
    relativePath: path.relative(rootDir, fullFilePath) || path.relative(path.dirname(rootDir), fullFilePath),
    isFile: stat.isFile(),
    isDirectory: stat.isDirectory(),
    size: stat.size,
    isSymbolicLink: false,
});
const generateAssetSymlinkFile = (rootDir, fullFilePath, stat, symlinkTarget) => (Object.assign(Object.assign({}, generateAssetFile(rootDir, fullFilePath, stat)), { isSymbolicLink: true, symlinkTarget }));
function listFilesRecursively(dirOrFile, options, _rootDir) {
    const files = [];
    const exclude = options.exclude || [];
    const rootDir = _rootDir || dirOrFile;
    const followStatsFn = options.follow === follow_mode_1.FollowMode.ALWAYS ? fs.statSync : fs.lstatSync;
    const excludeRules = new ExcludeRules(exclude);
    recurse(dirOrFile);
    function recurse(currentPath, _currentStat) {
        const currentStat = _currentStat || fs.statSync(currentPath);
        if (!currentStat) {
            return;
        }
        for (const file of currentStat.isDirectory() ? fs.readdirSync(currentPath) : ['']) {
            const fullFilePath = path.join(currentPath, file);
            const relativeFilePath = path.relative(rootDir, fullFilePath);
            let stat = followStatsFn(fullFilePath);
            if (!stat) {
                continue;
            }
            const isExcluded = excludeRules.excludeFile(relativeFilePath);
            if (!isExcluded) {
                let target = '';
                if (stat.isSymbolicLink()) {
                    target = fs.readlinkSync(fullFilePath);
                    // determine if this is an external link (i.e. the target's absolute path  is outside of the root directory).
                    const targetPath = path.normalize(path.resolve(currentPath, target));
                    if (shouldFollow(options.follow, rootDir, targetPath)) {
                        stat = fs.statSync(fullFilePath);
                        if (!stat) {
                            continue;
                        }
                    }
                }
                if (stat.isFile()) {
                    files.push(generateAssetFile(rootDir, fullFilePath, stat));
                }
                else if (stat.isSymbolicLink()) {
                    files.push(generateAssetSymlinkFile(rootDir, fullFilePath, stat, target));
                }
            }
            if (stat.isDirectory() && (!isExcluded || !excludeRules.excludeDirectory(relativeFilePath))) {
                const previousLength = files.length;
                recurse(fullFilePath, stat);
                if (files.length === previousLength && !isExcluded) {
                    // helps "copy" create an empty directory
                    files.push(generateAssetFile(rootDir, fullFilePath, stat));
                }
            }
        }
    }
    return files;
}
exports.listFilesRecursively = listFilesRecursively;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ1dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlCQUEwQjtBQUMxQix1Q0FBd0M7QUFDeEMsNkJBQThCO0FBRTlCLCtDQUEyQztBQUUzQzs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLE9BQWlCLEVBQUUsUUFBZ0I7SUFDL0QsTUFBTSxDQUFDLGNBQWMsQ0FBQyxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3RFLE9BQU8sY0FBYyxDQUFDO0FBQ3hCLENBQUM7QUFIRCxzQ0FHQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxZQUFZO0lBbUV2QixZQUFvQyxRQUFrQjtRQUFsQixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBYnJDLHNCQUFpQixHQUFlLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBYXpDLENBQUM7SUFsRTNEOzs7Ozs7OztPQVFHO0lBQ0ksTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFrQixFQUFFLFFBQWdCO1FBQzdELElBQUksY0FBYyxHQUFHLEtBQUssQ0FBQztRQUMzQixJQUFJLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUV4QixRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxFQUFFO1lBQ3JDLElBQUksU0FBUyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFO2dCQUN2RSxDQUFDLGNBQWMsRUFBRSxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQzthQUM3RTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLGNB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LEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FBQyxFQUFFO3dCQUNyRCxJQUFJLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQzt3QkFDakMsSUFBSSxDQUFDLElBQUksRUFBRTs0QkFDVCxTQUFTO3lCQUNWO3FCQUNGO2lCQUNGO2dCQUVELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFO29CQUNqQixLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDNUQ7cUJBQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQUU7b0JBQ2hDLEtBQUssQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztpQkFDM0U7YUFDRjtZQUVELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQyxVQUFVLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFO2dCQUMzRixNQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO2dCQUNwQyxPQUFPLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUU1QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssY0FBYyxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNsRCx5Q0FBeUM7b0JBQ3pDLEtBQUssQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO2lCQUM1RDthQUNGO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBaEVELG9EQWdFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5pbXBvcnQgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCB7IENvcHlPcHRpb25zIH0gZnJvbSAnLi9jb3B5LW9wdGlvbnMnO1xuaW1wb3J0IHsgRm9sbG93TW9kZSB9IGZyb20gJy4vZm9sbG93LW1vZGUnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIGZpbGUgc2hvdWxkIGJlIGV4Y2x1ZGVkIG9yIG5vdCBiYXNlZCBvbiBnaXZlblxuICogZXhjbHVzaW9uIGdsb2IgcGF0dGVybnMuXG4gKlxuICogQHBhcmFtIGV4Y2x1ZGUgIGV4Y2x1c2lvbiBwYXR0ZXJuc1xuICogQHBhcmFtIGZpbGVQYXRoIGZpbGUgcGF0aCB0byBiZSBhc3Nlc3NlZCBhZ2FpbnN0IHRoZSBwYXR0ZXJuXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBmaWxlIHNob3VsZCBiZSBleGNsdWRlZFxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSB7QGxpbmsgRXhjbHVkZVJ1bGVzLmV4Y2x1ZGVGaWxlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkRXhjbHVkZShleGNsdWRlOiBzdHJpbmdbXSwgZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBbX3Nob3VsZEV4Y2x1ZGVdID0gRXhjbHVkZVJ1bGVzLmV2YWx1YXRlRmlsZShleGNsdWRlLCBmaWxlUGF0aCk7XG4gIHJldHVybiBfc2hvdWxkRXhjbHVkZTtcbn1cblxuLyoqXG4gKiBTZXQgb2YgZXhjbHVzaW9uIGV2YWx1YXRpb24gbWV0aG9kc1xuICovXG5leHBvcnQgY2xhc3MgRXhjbHVkZVJ1bGVzIHtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIGZpbGUgc2hvdWxkIGJlIGV4Y2x1ZGVkIG9yIG5vdCBiYXNlZCBvbiBnaXZlblxuICAgKiBleGNsdXNpb24gZ2xvYiBwYXR0ZXJucy5cbiAgICpcbiAgICogQHBhcmFtIHBhdHRlcm5zICBleGNsdXNpb24gcGF0dGVybnNcbiAgICogQHBhcmFtIGZpbGVQYXRoIGZpbGUgcGF0aCB0byBiZSBhc3Nlc3NlZCBhZ2FpbnN0IHRoZSBwYXR0ZXJuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlsZSBzaG91bGQgYmUgZXhjbHVkZWQsIGZvbGxvd2VkIGJ5IHRoZSBpbmRleCBvZiB0aGUgcnVsZSBhcHBsaWVkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGV2YWx1YXRlRmlsZShwYXR0ZXJuczogc3RyaW5nW10sIGZpbGVQYXRoOiBzdHJpbmcpOiBbYm9vbGVhbiwgbnVtYmVyXSB7XG4gICAgbGV0IF9zaG91bGRFeGNsdWRlID0gZmFsc2U7XG4gICAgbGV0IGV4Y2x1c2lvbkluZGV4ID0gLTE7XG5cbiAgICBwYXR0ZXJucy5tYXAoKHBhdHRlcm4sIHBhdHRlcm5JbmRleCkgPT4ge1xuICAgICAgaWYgKG1pbmltYXRjaChmaWxlUGF0aCwgcGF0dGVybiwgeyBtYXRjaEJhc2U6IHRydWUsIGZsaXBOZWdhdGU6IHRydWUgfSkpIHtcbiAgICAgICAgW19zaG91bGRFeGNsdWRlLCBleGNsdXNpb25JbmRleF0gPSBbIXBhdHRlcm4uc3RhcnRzV2l0aCgnIScpLCBwYXR0ZXJuSW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtfc2hvdWxkRXhjbHVkZSwgZXhjbHVzaW9uSW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIGZpbGUgb3IgZGlyZWN0b3J5IHBhdGggaW4gYW4gYXJyYXkgb2YgZWxlbWVudHNcbiAgICogY29udGFpbmluZyBlYWNoIHBhdGggY29tcG9uZW50IChkaXJlY3RvcmllcyBhbmQgZmlsZSlcbiAgICpcbiAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBwYXRoIHRvIHNwbGl0XG4gICAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBwYXRoIGNvbXBvbmVudFxuICAgKlxuICAgKiBAZXhhbXBsZSBFeGNsdWRlUnVsZXMuZ2V0UGF0aENvbXBvbmVudHMoJ2EvYi9jJykgPSBbJ2EnLCAnYicsICdjJ11cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldFBhdGhDb21wb25lbnRzID0gKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSA9PiBmaWxlUGF0aC5zcGxpdChwYXRoLnNlcCk7XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIGZpbGUgb3IgZGlyZWN0b3J5IHBhdGggaW4gYW4gYXJyYXkgb2YgZWxlbWVudHNcbiAgICogY29udGFpbmluZyBlYWNoIHBhcnRpYWwgcGF0aCB1cCB0byB0aGF0IHBvaW50XG4gICAqXG4gICAqIEBwYXJhbSBmaWxlUGF0aCB0aGUgcGF0aCB0byBzcGxpdFxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGVhY2ggcGF0aCBjb21wb25lbnRcbiAgICpcbiAgICogQGV4YW1wbGUgRXhjbHVkZVJ1bGVzLmdldEFjY3VtdWxhdGVkUGF0aENvbXBvbmVudHMoJ2EvYi9jJykgPSBbJ2EnLCAnYS9iJywgJ2EvYi9jJ11cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEFjY3VtdWxhdGVkUGF0aENvbXBvbmVudHMoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBhY2NDb21wb25lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIEV4Y2x1ZGVSdWxlcy5nZXRQYXRoQ29tcG9uZW50cyhmaWxlUGF0aCkpIHtcbiAgICAgIGFjY0NvbXBvbmVudHMucHVzaChhY2NDb21wb25lbnRzLmxlbmd0aCA/XG4gICAgICAgIFthY2NDb21wb25lbnRzW2FjY0NvbXBvbmVudHMubGVuZ3RoIC0gMV0sIGNvbXBvbmVudF0uam9pbihwYXRoLnNlcCkgOlxuICAgICAgICBjb21wb25lbnRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhY2NDb21wb25lbnRzO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBwYXR0ZXJuQ29tcG9uZW50czogc3RyaW5nW11bXSA9IHRoaXMucGF0dGVybnMubWFwKEV4Y2x1ZGVSdWxlcy5nZXRQYXRoQ29tcG9uZW50cyk7XG4gIHByaXZhdGUgZ2V0IGFjY3VtdWxhdGVkUGF0dGVybkNvbXBvbmVudHMoKTogc3RyaW5nW11bXSB7XG4gICAgY29uc3QgcGF0dGVybkNvbXBvbmVudHNMZW5ndGggPSB0aGlzLnBhdHRlcm5Db21wb25lbnRzLm1hcCgoeyBsZW5ndGggfSkgPT4gbGVuZ3RoKTtcbiAgICBjb25zdCBtYXhQYXR0ZXJuTGVuZ3RoID0gTWF0aC5tYXgoLi4ucGF0dGVybkNvbXBvbmVudHNMZW5ndGgpO1xuXG4gICAgY29uc3QgYWNjUGF0dGVybkNvbXBvbmVudHM6IHN0cmluZ1tdW10gPSBbXTtcbiAgICBmb3IgKGxldCBwYXR0ZW5Db21wb25lbnRzTGVuZ3RoID0gMTsgcGF0dGVuQ29tcG9uZW50c0xlbmd0aCA8PSBtYXhQYXR0ZXJuTGVuZ3RoOyArK3BhdHRlbkNvbXBvbmVudHNMZW5ndGgpIHtcbiAgICAgIGFjY1BhdHRlcm5Db21wb25lbnRzLnB1c2godGhpcy5wYXR0ZXJuQ29tcG9uZW50cy5tYXAoKHBhdHRlcm4pID0+IHBhdHRlcm4uc2xpY2UoMCwgcGF0dGVuQ29tcG9uZW50c0xlbmd0aCkuam9pbihwYXRoLnNlcCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjUGF0dGVybkNvbXBvbmVudHM7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXR0ZXJuczogc3RyaW5nW10pIHsgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBmaWxlIHNob3VsZCBiZSBleGNsdWRlZCx0YWtpbmcgaW50byBhY2NvdW50IGRlZXAgZmlsZSBzdHJ1Y3R1cmVzXG4gICAqXG4gICAqIEBwYXJhbSBmaWxlUGF0aCBmaWxlIHBhdGggdG8gYmUgYXNzZXNzZWQgYWdhaW5zdCB0aGUgcGF0dGVyblxuICAgKi9cbiAgcHVibGljIGV4Y2x1ZGVGaWxlKHJlbGF0aXZlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgbGV0IGFjY0V4Y2x1ZGUgPSBmYWxzZTtcbiAgICBsZXQgYWNjUHJpb3JpdHkgPSAtMTtcblxuICAgIGZvciAoY29uc3QgYWNjUGF0aCBvZiBFeGNsdWRlUnVsZXMuZ2V0QWNjdW11bGF0ZWRQYXRoQ29tcG9uZW50cyhyZWxhdGl2ZVBhdGgpKSB7XG4gICAgICBjb25zdCBbc2hvdWxkRXhjbHVkZUl0LCBwcmlvcml0eUl0XSA9IEV4Y2x1ZGVSdWxlcy5ldmFsdWF0ZUZpbGUodGhpcy5wYXR0ZXJucywgYWNjUGF0aCk7XG4gICAgICBpZiAocHJpb3JpdHlJdCA+IGFjY1ByaW9yaXR5KSB7XG4gICAgICAgIFthY2NFeGNsdWRlLCBhY2NQcmlvcml0eV0gPSBbc2hvdWxkRXhjbHVkZUl0LCBwcmlvcml0eUl0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjRXhjbHVkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBkaXJlY3Rvcnkgc2hvdWxkIGJlIGV4Y2x1ZGVkIGFuZCBub3QgZXhwbG9yZWQgZnVydGhlclxuICAgKiBUaGlzIG1pZ2h0IGJlIGB0cnVlYCBldmVuIGlmIHRoZSBkaXJlY3RvcnkgaXMgZXhwbGljaXRseSBleGNsdWRlZCxcbiAgICogYnV0IG9uZSBvZiBpdHMgY2hpbGRyZW4gbWlnaHQgYmUgaW5jbHVuZGVkXG4gICAqXG4gICAqIEBwYXJhbSBkaXJlY3RvcnlQYXRoIGRpcmVjdG9yeSBwYXRoIHRvIGJlIGFzc2Vzc2VkIGFnYWluc3QgdGhlIHBhdHRlcm5cbiAgICovXG4gIHB1YmxpYyBleGNsdWRlRGlyZWN0b3J5KGRpcmVjdG9yeVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGxldCBfc2hvdWxkRXhjbHVkZTogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBhY2NQYXRoIG9mIEV4Y2x1ZGVSdWxlcy5nZXRBY2N1bXVsYXRlZFBhdGhDb21wb25lbnRzKGRpcmVjdG9yeVBhdGgpKSB7XG4gICAgICB0aGlzLmFjY3VtdWxhdGVkUGF0dGVybkNvbXBvbmVudHMubWFwKChhY2N1bXVsYXRlZFBhdHRlcm5zLCBhY2N1bXVsYXRlZEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IFtzaG91bGRFeGNsdWRlSXQsIHBhdHRlcm5JbmRleF0gPSBFeGNsdWRlUnVsZXMuZXZhbHVhdGVGaWxlKGFjY3VtdWxhdGVkUGF0dGVybnMsIGFjY1BhdGgpO1xuICAgICAgICBpZiAocGF0dGVybkluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRFeGNsdWRlSXQpIHtcbiAgICAgICAgICBpZiAoX3Nob3VsZEV4Y2x1ZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIF9zaG91bGRFeGNsdWRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWNjdW11bGF0ZWRJbmRleCA8IHRoaXMucGF0dGVybkNvbXBvbmVudHNbcGF0dGVybkluZGV4XS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgX3Nob3VsZEV4Y2x1ZGUgPSBzaG91bGRFeGNsdWRlSXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFjY3VtdWxhdGVkUGF0dGVybnNbcGF0dGVybkluZGV4XS5pbmNsdWRlcygnKionKSkge1xuICAgICAgICAgIF9zaG91bGRFeGNsdWRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zaG91bGRFeGNsdWRlIHx8IGZhbHNlO1xuICB9XG5cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzeW1saW5rIHNob3VsZCBiZSBmb2xsb3dlZCBvciBub3QsIGJhc2VkIG9uIGEgRm9sbG93TW9kZS5cbiAqXG4gKiBAcGFyYW0gbW9kZSAgICAgICB0aGUgRm9sbG93TW9kZS5cbiAqIEBwYXJhbSBzb3VyY2VSb290IHRoZSByb290IG9mIHRoZSBzb3VyY2UgdHJlZS5cbiAqIEBwYXJhbSByZWFsUGF0aCAgIHRoZSByZWFsIHBhdGggb2YgdGhlIHRhcmdldCBvZiB0aGUgc3ltbGluay5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBsaW5rIHNob3VsZCBiZSBmb2xsb3dlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEZvbGxvdyhtb2RlOiBGb2xsb3dNb2RlLCBzb3VyY2VSb290OiBzdHJpbmcsIHJlYWxQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBGb2xsb3dNb2RlLkFMV0FZUzpcbiAgICAgIHJldHVybiBmcy5leGlzdHNTeW5jKHJlYWxQYXRoKTtcbiAgICBjYXNlIEZvbGxvd01vZGUuRVhURVJOQUw6XG4gICAgICByZXR1cm4gIV9pc0ludGVybmFsKCkgJiYgZnMuZXhpc3RzU3luYyhyZWFsUGF0aCk7XG4gICAgY2FzZSBGb2xsb3dNb2RlLkJMT0NLX0VYVEVSTkFMOlxuICAgICAgcmV0dXJuIF9pc0ludGVybmFsKCkgJiYgZnMuZXhpc3RzU3luYyhyZWFsUGF0aCk7XG4gICAgY2FzZSBGb2xsb3dNb2RlLk5FVkVSOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEZvbGxvd01vZGU6ICR7bW9kZX1gKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0ludGVybmFsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUocmVhbFBhdGgpLnN0YXJ0c1dpdGgocGF0aC5yZXNvbHZlKHNvdXJjZVJvb3QpKTtcbiAgfVxufVxuXG50eXBlIEFzc2V0RmlsZSA9IHtcbiAgYWJzb2x1dGVQYXRoOiBzdHJpbmc7XG4gIHJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICBpc0ZpbGU6IGJvb2xlYW47XG4gIGlzRGlyZWN0b3J5OiBib29sZWFuO1xuICBzaXplOiBudW1iZXI7XG59ICYgKHsgaXNTeW1ib2xpY0xpbms6IGZhbHNlIH0gfCB7IGlzU3ltYm9saWNMaW5rOiB0cnVlOyBzeW1saW5rVGFyZ2V0OiBzdHJpbmcgfSk7XG5cbmNvbnN0IGdlbmVyYXRlQXNzZXRGaWxlID0gKHJvb3REaXI6IHN0cmluZywgZnVsbEZpbGVQYXRoOiBzdHJpbmcsIHN0YXQ6IGZzLlN0YXRzKTogQXNzZXRGaWxlID0+ICh7XG4gIGFic29sdXRlUGF0aDogZnVsbEZpbGVQYXRoLFxuICByZWxhdGl2ZVBhdGg6IHBhdGgucmVsYXRpdmUocm9vdERpciwgZnVsbEZpbGVQYXRoKSB8fCBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShyb290RGlyKSwgZnVsbEZpbGVQYXRoKSxcbiAgaXNGaWxlOiBzdGF0LmlzRmlsZSgpLFxuICBpc0RpcmVjdG9yeTogc3RhdC5pc0RpcmVjdG9yeSgpLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGlzU3ltYm9saWNMaW5rOiBmYWxzZSxcbn0pO1xuXG5jb25zdCBnZW5lcmF0ZUFzc2V0U3ltbGlua0ZpbGUgPSAocm9vdERpcjogc3RyaW5nLCBmdWxsRmlsZVBhdGg6IHN0cmluZywgc3RhdDogZnMuU3RhdHMsIHN5bWxpbmtUYXJnZXQ6IHN0cmluZyk6IEFzc2V0RmlsZSA9PiAoe1xuICAuLi5nZW5lcmF0ZUFzc2V0RmlsZShyb290RGlyLCBmdWxsRmlsZVBhdGgsIHN0YXQpLFxuICBpc1N5bWJvbGljTGluazogdHJ1ZSxcbiAgc3ltbGlua1RhcmdldCxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gbGlzdEZpbGVzUmVjdXJzaXZlbHkoXG4gIGRpck9yRmlsZTogc3RyaW5nLFxuICBvcHRpb25zOiBDb3B5T3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8Q29weU9wdGlvbnMsICdmb2xsb3cnPj4sIF9yb290RGlyPzogc3RyaW5nXG4pOiBBc3NldEZpbGVbXSB7XG4gIGNvbnN0IGZpbGVzOiBBc3NldEZpbGVbXSA9IFtdO1xuICBjb25zdCBleGNsdWRlID0gb3B0aW9ucy5leGNsdWRlIHx8IFtdO1xuICBjb25zdCByb290RGlyID0gX3Jvb3REaXIgfHwgZGlyT3JGaWxlO1xuICBjb25zdCBmb2xsb3dTdGF0c0ZuID0gb3B0aW9ucy5mb2xsb3cgPT09IEZvbGxvd01vZGUuQUxXQVlTID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmM7XG5cbiAgY29uc3QgZXhjbHVkZVJ1bGVzID0gbmV3IEV4Y2x1ZGVSdWxlcyhleGNsdWRlKTtcblxuICByZWN1cnNlKGRpck9yRmlsZSk7XG5cbiAgZnVuY3Rpb24gcmVjdXJzZShjdXJyZW50UGF0aDogc3RyaW5nLCBfY3VycmVudFN0YXQ/OiBmcy5TdGF0cyk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ID0gX2N1cnJlbnRTdGF0IHx8IGZzLnN0YXRTeW5jKGN1cnJlbnRQYXRoKTtcbiAgICBpZiAoIWN1cnJlbnRTdGF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGN1cnJlbnRTdGF0LmlzRGlyZWN0b3J5KCkgPyBmcy5yZWFkZGlyU3luYyhjdXJyZW50UGF0aCkgOiBbJyddKSB7XG4gICAgICBjb25zdCBmdWxsRmlsZVBhdGggPSBwYXRoLmpvaW4oY3VycmVudFBhdGgsIGZpbGUpO1xuICAgICAgY29uc3QgcmVsYXRpdmVGaWxlUGF0aCA9IHBhdGgucmVsYXRpdmUocm9vdERpciwgZnVsbEZpbGVQYXRoKTtcblxuICAgICAgbGV0IHN0YXQ6IGZzLlN0YXRzIHwgdW5kZWZpbmVkID0gZm9sbG93U3RhdHNGbihmdWxsRmlsZVBhdGgpO1xuICAgICAgaWYgKCFzdGF0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0V4Y2x1ZGVkID0gZXhjbHVkZVJ1bGVzLmV4Y2x1ZGVGaWxlKHJlbGF0aXZlRmlsZVBhdGgpO1xuICAgICAgaWYgKCFpc0V4Y2x1ZGVkKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSAnJztcbiAgICAgICAgaWYgKHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgIHRhcmdldCA9IGZzLnJlYWRsaW5rU3luYyhmdWxsRmlsZVBhdGgpO1xuXG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYW4gZXh0ZXJuYWwgbGluayAoaS5lLiB0aGUgdGFyZ2V0J3MgYWJzb2x1dGUgcGF0aCAgaXMgb3V0c2lkZSBvZiB0aGUgcm9vdCBkaXJlY3RvcnkpLlxuICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLnJlc29sdmUoY3VycmVudFBhdGgsIHRhcmdldCkpO1xuICAgICAgICAgIGlmIChzaG91bGRGb2xsb3cob3B0aW9ucy5mb2xsb3csIHJvb3REaXIsIHRhcmdldFBhdGgpKSB7XG4gICAgICAgICAgICBzdGF0ID0gZnMuc3RhdFN5bmMoZnVsbEZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmICghc3RhdCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgICAgIGZpbGVzLnB1c2goZ2VuZXJhdGVBc3NldEZpbGUocm9vdERpciwgZnVsbEZpbGVQYXRoLCBzdGF0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgZmlsZXMucHVzaChnZW5lcmF0ZUFzc2V0U3ltbGlua0ZpbGUocm9vdERpciwgZnVsbEZpbGVQYXRoLCBzdGF0LCB0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpICYmICghaXNFeGNsdWRlZCB8fCAhZXhjbHVkZVJ1bGVzLmV4Y2x1ZGVEaXJlY3RvcnkocmVsYXRpdmVGaWxlUGF0aCkpKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gZmlsZXMubGVuZ3RoO1xuICAgICAgICByZWN1cnNlKGZ1bGxGaWxlUGF0aCwgc3RhdCk7XG5cbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gcHJldmlvdXNMZW5ndGggJiYgIWlzRXhjbHVkZWQpIHtcbiAgICAgICAgICAvLyBoZWxwcyBcImNvcHlcIiBjcmVhdGUgYW4gZW1wdHkgZGlyZWN0b3J5XG4gICAgICAgICAgZmlsZXMucHVzaChnZW5lcmF0ZUFzc2V0RmlsZShyb290RGlyLCBmdWxsRmlsZVBhdGgsIHN0YXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWxlcztcbn1cbiJdfQ==