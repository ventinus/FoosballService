#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const colors = require("colors/safe");
const path = require("path");
const yargs = require("yargs");
const lib_1 = require("../lib");
const environments_1 = require("../lib/api/cxapp/environments");
const exec_1 = require("../lib/api/cxapp/exec");
const stacks_1 = require("../lib/api/cxapp/stacks");
const deployment_target_1 = require("../lib/api/deployment-target");
const cdk_toolkit_1 = require("../lib/cdk-toolkit");
const diff_1 = require("../lib/diff");
const init_1 = require("../lib/init");
const logging_1 = require("../lib/logging");
const plugin_1 = require("../lib/plugin");
const serialize_1 = require("../lib/serialize");
const settings_1 = require("../lib/settings");
const version = require("../lib/version");
// tslint:disable:no-shadowed-variable max-line-length
async function parseCommandLineArguments() {
    const initTemplateLanuages = await init_1.availableInitLanguages;
    return yargs
        .env('CDK')
        .usage('Usage: cdk -a <cdk-app> COMMAND')
        .option('app', { type: 'string', alias: 'a', desc: 'REQUIRED: command-line for executing your app or a cloud assembly directory (e.g. "node bin/my-app.js")', requiresArg: true })
        .option('context', { type: 'array', alias: 'c', desc: 'Add contextual string parameter (KEY=VALUE)', nargs: 1, requiresArg: true })
        .option('plugin', { type: 'array', alias: 'p', desc: 'Name or path of a node package that extend the CDK features. Can be specified multiple times', nargs: 1 })
        .option('trace', { type: 'boolean', desc: 'Print trace for stack warnings' })
        .option('strict', { type: 'boolean', desc: 'Do not construct stacks with warnings' })
        .option('ignore-errors', { type: 'boolean', default: false, desc: 'Ignores synthesis errors, which will likely produce an invalid output' })
        .option('json', { type: 'boolean', alias: 'j', desc: 'Use JSON output instead of YAML when templates are printed to STDOUT', default: false })
        .option('verbose', { type: 'boolean', alias: 'v', desc: 'Show debug logs', default: false })
        .option('profile', { type: 'string', desc: 'Use the indicated AWS profile as the default environment', requiresArg: true })
        .option('proxy', { type: 'string', desc: 'Use the indicated proxy. Will read from HTTPS_PROXY environment variable if not specified.', requiresArg: true })
        .option('ec2creds', { type: 'boolean', alias: 'i', default: undefined, desc: 'Force trying to fetch EC2 instance credentials. Default: guess EC2 instance status.' })
        .option('version-reporting', { type: 'boolean', desc: 'Include the "AWS::CDK::Metadata" resource in synthesized templates (enabled by default)', default: undefined })
        .option('path-metadata', { type: 'boolean', desc: 'Include "aws:cdk:path" CloudFormation metadata for each resource (enabled by default)', default: true })
        .option('asset-metadata', { type: 'boolean', desc: 'Include "aws:asset:*" CloudFormation metadata for resources that user assets (enabled by default)', default: true })
        .option('role-arn', { type: 'string', alias: 'r', desc: 'ARN of Role to use when invoking CloudFormation', default: undefined, requiresArg: true })
        .option('toolkit-stack-name', { type: 'string', desc: 'The name of the CDK toolkit stack', requiresArg: true })
        .option('staging', { type: 'boolean', desc: 'Copy assets to the output directory (use --no-staging to disable, needed for local debugging the source files with SAM CLI)', default: true })
        .option('output', { type: 'string', alias: 'o', desc: 'Emits the synthesized cloud assembly into a directory (default: cdk.out)', requiresArg: true })
        .option('no-color', { type: 'boolean', desc: 'Removes colors and other style from console output', default: false })
        .command(['list [STACKS..]', 'ls [STACKS..]'], 'Lists all stacks in the app', yargs => yargs
        .option('long', { type: 'boolean', default: false, alias: 'l', desc: 'Display environment information for each stack' }))
        .command(['synthesize [STACKS..]', 'synth [STACKS..]'], 'Synthesizes and prints the CloudFormation template for this stack', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependencies' }))
        .command('bootstrap [ENVIRONMENTS..]', 'Deploys the CDK toolkit stack into an AWS environment', yargs => yargs
        .option('bootstrap-bucket-name', { type: 'string', alias: ['b', 'toolkit-bucket-name'], desc: 'The name of the CDK toolkit bucket', default: undefined })
        .option('bootstrap-kms-key-id', { type: 'string', desc: 'AWS KMS master key ID used for the SSE-KMS encryption', default: undefined })
        .option('tags', { type: 'array', alias: 't', desc: 'Tags to add for the stack (KEY=VALUE)', nargs: 1, requiresArg: true, default: [] }))
        .command('deploy [STACKS..]', 'Deploys the stack(s) named STACKS into your AWS account', yargs => yargs
        .option('build-exclude', { type: 'array', alias: 'E', nargs: 1, desc: 'Do not rebuild asset with the given ID. Can be specified multiple times.', default: [] })
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependencies' })
        .option('require-approval', { type: 'string', choices: [diff_1.RequireApproval.Never, diff_1.RequireApproval.AnyChange, diff_1.RequireApproval.Broadening], desc: 'What security-sensitive changes need manual approval' })
        .option('ci', { type: 'boolean', desc: 'Force CI detection. Use --no-ci to disable CI autodetection.', default: process.env.CI !== undefined })
        .option('notification-arns', { type: 'array', desc: 'ARNs of SNS topics that CloudFormation will notify with stack related events', nargs: 1, requiresArg: true })
        .option('tags', { type: 'array', alias: 't', desc: 'Tags to add to the stack (KEY=VALUE)', nargs: 1, requiresArg: true }))
        .command('destroy [STACKS..]', 'Destroy the stack(s) named STACKS', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependees' })
        .option('force', { type: 'boolean', alias: 'f', desc: 'Do not ask for confirmation before destroying the stacks' }))
        .command('diff [STACKS..]', 'Compares the specified stack with the deployed stack or a local template file, and returns with status 1 if any difference is found', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only diff requested stacks, don\'t include dependencies' })
        .option('context-lines', { type: 'number', desc: 'Number of context lines to include in arbitrary JSON diff rendering', default: 3, requiresArg: true })
        .option('template', { type: 'string', desc: 'The path to the CloudFormation template to compare with', requiresArg: true })
        .option('strict', { type: 'boolean', desc: 'Do not filter out AWS::CDK::Metadata resources', default: false }))
        .command('metadata [STACK]', 'Returns all metadata associated with this stack')
        .command('init [TEMPLATE]', 'Create a new, empty CDK project from a template. Invoked without TEMPLATE, the app template will be used.', yargs => yargs
        .option('language', { type: 'string', alias: 'l', desc: 'The language to be used for the new project (default can be configured in ~/.cdk.json)', choices: initTemplateLanuages })
        .option('list', { type: 'boolean', desc: 'List the available templates' })
        .option('generate-only', { type: 'boolean', default: false, desc: 'If true, only generates project files, without executing additional operations such as setting up a git repo, installing dependencies or compiling the project' }))
        .commandDir('../lib/commands', { exclude: /^_.*/ })
        .version(version.DISPLAY_VERSION)
        .demandCommand(1, '') // just print help
        .help()
        .alias('h', 'help')
        .epilogue([
        'If your app has a single stack, there is no need to specify the stack name',
        'If one of cdk.json or ~/.cdk.json exists, options specified there will be used as defaults. Settings in cdk.json take precedence.'
    ].join('\n\n'))
        .argv;
}
if (!process.stdout.isTTY) {
    colors.disable();
}
async function initCommandLine() {
    const argv = await parseCommandLineArguments();
    if (argv.verbose) {
        logging_1.setVerbose();
    }
    logging_1.debug('CDK toolkit version:', version.DISPLAY_VERSION);
    logging_1.debug('Command line arguments:', argv);
    const aws = new lib_1.SDK({
        profile: argv.profile,
        proxyAddress: argv.proxy,
        ec2creds: argv.ec2creds,
    });
    const configuration = new settings_1.Configuration(argv);
    await configuration.load();
    const provisioner = new deployment_target_1.CloudFormationDeploymentTarget({ aws });
    const appStacks = new stacks_1.AppStacks({
        verbose: argv.trace || argv.verbose,
        ignoreErrors: argv['ignore-errors'],
        strict: argv.strict,
        configuration,
        aws,
        synthesizer: exec_1.execProgram,
    });
    /** Function to load plug-ins, using configurations additively. */
    function loadPlugins(...settings) {
        const loaded = new Set();
        for (const source of settings) {
            const plugins = source.get(['plugin']) || [];
            for (const plugin of plugins) {
                const resolved = tryResolve(plugin);
                if (loaded.has(resolved)) {
                    continue;
                }
                logging_1.debug(`Loading plug-in: ${colors.green(plugin)} from ${colors.blue(resolved)}`);
                plugin_1.PluginHost.instance.load(plugin);
                loaded.add(resolved);
            }
        }
        function tryResolve(plugin) {
            try {
                return require.resolve(plugin);
            }
            catch (e) {
                logging_1.error(`Unable to resolve plugin ${colors.green(plugin)}: ${e.stack}`);
                throw new Error(`Unable to resolve plug-in: ${plugin}`);
            }
        }
    }
    loadPlugins(configuration.settings);
    const cmd = argv._[0];
    // Bundle up global objects so the commands have access to them
    const commandOptions = { args: argv, appStacks, configuration, aws };
    try {
        const returnValue = argv.commandHandler
            ? await argv.commandHandler(commandOptions)
            : await main(cmd, argv);
        if (typeof returnValue === 'object') {
            return toJsonOrYaml(returnValue);
        }
        else if (typeof returnValue === 'string') {
            return returnValue;
        }
        else {
            return returnValue;
        }
    }
    finally {
        await version.displayVersionMessage();
    }
    async function main(command, args) {
        const toolkitStackName = configuration.settings.get(['toolkitStackName']) || deployment_target_1.DEFAULT_TOOLKIT_STACK_NAME;
        if (toolkitStackName !== deployment_target_1.DEFAULT_TOOLKIT_STACK_NAME) {
            logging_1.print(`Toolkit stack: ${colors.bold(toolkitStackName)}`);
        }
        args.STACKS = args.STACKS || [];
        args.ENVIRONMENTS = args.ENVIRONMENTS || [];
        const cli = new cdk_toolkit_1.CdkToolkit({ appStacks, provisioner });
        switch (command) {
            case 'ls':
            case 'list':
                return await cliList(args.STACKS, { long: args.long });
            case 'diff':
                return await cli.diff({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    templatePath: args.template,
                    strict: args.strict,
                    contextLines: args.contextLines
                });
            case 'bootstrap':
                return await cliBootstrap(args.ENVIRONMENTS, toolkitStackName, args.roleArn, {
                    bucketName: configuration.settings.get(['toolkitBucket', 'bucketName']),
                    kmsKeyId: configuration.settings.get(['toolkitBucket', 'kmsKeyId']),
                    tags: configuration.settings.get(['tags'])
                });
            case 'deploy':
                return await cli.deploy({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    toolkitStackName,
                    roleArn: args.roleArn,
                    notificationArns: args.notificationArns,
                    requireApproval: configuration.settings.get(['requireApproval']),
                    ci: args.ci,
                    reuseAssets: args['build-exclude'],
                    tags: configuration.settings.get(['tags']),
                    sdk: aws,
                });
            case 'destroy':
                return await cli.destroy({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    force: args.force,
                    roleArn: args.roleArn,
                    sdk: aws,
                });
            case 'synthesize':
            case 'synth':
                return await cliSynthesize(args.STACKS, args.exclusively);
            case 'metadata':
                return await cliMetadata(await findStack(args.STACK));
            case 'init':
                const language = configuration.settings.get(['language']);
                const generateOnly = configuration.settings.get(['generate-only']);
                if (args.list) {
                    return await init_1.printAvailableTemplates(language);
                }
                else {
                    return await init_1.cliInit(args.TEMPLATE, language, undefined, generateOnly);
                }
            case 'version':
                return logging_1.print(version.DISPLAY_VERSION);
            default:
                throw new Error('Unknown command: ' + command);
        }
    }
    async function cliMetadata(stackName) {
        const s = await appStacks.synthesizeStack(stackName);
        return s.manifest.metadata || {};
    }
    /**
     * Bootstrap the CDK Toolkit stack in the accounts used by the specified stack(s).
     *
     * @param environmentGlobs environment names that need to have toolkit support
     *             provisioned, as a glob filter. If none is provided,
     *             all stacks are implicitly selected.
     * @param toolkitStackName the name to be used for the CDK Toolkit stack.
     */
    async function cliBootstrap(environmentGlobs, toolkitStackName, roleArn, props) {
        // Two modes of operation.
        //
        // If there is an '--app' argument, we select the environments from the app. Otherwise we just take the user
        // at their word that they know the name of the environment.
        const app = configuration.settings.get(['app']);
        const environments = app ? await environments_1.globEnvironmentsFromStacks(appStacks, environmentGlobs, aws) : environments_1.environmentsFromDescriptors(environmentGlobs);
        await Promise.all(environments.map(async (environment) => {
            logging_1.success(' ⏳  Bootstrapping environment %s...', colors.blue(environment.name));
            try {
                const result = await lib_1.bootstrapEnvironment(environment, aws, toolkitStackName, roleArn, props);
                const message = result.noOp ? ' ✅  Environment %s bootstrapped (no changes).'
                    : ' ✅  Environment %s bootstrapped.';
                logging_1.success(message, colors.blue(environment.name));
            }
            catch (e) {
                logging_1.error(' ❌  Environment %s failed bootstrapping: %s', colors.blue(environment.name), e);
                throw e;
            }
        }));
    }
    /**
     * Synthesize the given set of stacks (called when the user runs 'cdk synth')
     *
     * INPUT: Stack names can be supplied using a glob filter. If no stacks are
     * given, all stacks from the application are implictly selected.
     *
     * OUTPUT: If more than one stack ends up being selected, an output directory
     * should be supplied, where the templates will be written.
     */
    async function cliSynthesize(stackIds, exclusively) {
        // Only autoselect dependencies if it doesn't interfere with user request or output options
        const autoSelectDependencies = !exclusively;
        const stacks = await appStacks.selectStacks(stackIds, {
            extend: autoSelectDependencies ? stacks_1.ExtendedStackSelection.Upstream : stacks_1.ExtendedStackSelection.None,
            defaultBehavior: stacks_1.DefaultSelection.AllStacks
        });
        appStacks.processMetadata(stacks);
        // if we have a single stack, print it to STDOUT
        if (stacks.length === 1) {
            return stacks[0].template;
        }
        // This is a slight hack; in integ mode we allow multiple stacks to be synthesized to stdout sequentially.
        // This is to make it so that we can support multi-stack integ test expectations, without so drastically
        // having to change the synthesis format that we have to rerun all integ tests.
        //
        // Because this feature is not useful to consumers (the output is missing
        // the stack names), it's not exposed as a CLI flag. Instead, it's hidden
        // behind an environment variable.
        const isIntegMode = process.env.CDK_INTEG_MODE === '1';
        if (isIntegMode) {
            return stacks.map(s => s.template);
        }
        // not outputting template to stdout, let's explain things to the user a little bit...
        logging_1.success(`Successfully synthesized to ${colors.blue(path.resolve(appStacks.assembly.directory))}`);
        logging_1.print(`Supply a stack id (${stacks.map(s => colors.green(s.id)).join(', ')}) to display its template.`);
        return undefined;
    }
    async function cliList(selectors, options = {}) {
        const stacks = await appStacks.selectStacks(selectors, { defaultBehavior: stacks_1.DefaultSelection.AllStacks });
        // if we are in "long" mode, emit the array as-is (JSON/YAML)
        if (options.long) {
            const long = [];
            for (const stack of stacks) {
                long.push({
                    id: stack.id,
                    name: stack.stackName,
                    environment: stack.environment
                });
            }
            return long; // will be YAML formatted output
        }
        // just print stack IDs
        for (const stack of stacks) {
            logging_1.data(stack.id);
        }
        return 0; // exit-code
    }
    /**
     * Match a single stack from the list of available stacks
     */
    async function findStack(artifactId) {
        const stacks = await appStacks.selectStacks([artifactId], {
            extend: stacks_1.ExtendedStackSelection.None,
            defaultBehavior: stacks_1.DefaultSelection.None
        });
        // Could have been a glob so check that we evaluated to exactly one
        if (stacks.length > 1) {
            throw new Error(`This command requires exactly one stack and we matched more than one: ${stacks.map(x => x.id)}`);
        }
        return stacks[0].id;
    }
    function toJsonOrYaml(object) {
        return serialize_1.serializeStructure(object, argv.json);
    }
}
initCommandLine()
    .then(value => {
    if (value == null) {
        return;
    }
    if (typeof value === 'string') {
        logging_1.data(value);
    }
    else if (typeof value === 'number') {
        process.exit(value);
    }
})
    .catch(err => {
    logging_1.error(err.message);
    logging_1.debug(err.stack);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHVDQUFxQztBQUVyQyxzQ0FBdUM7QUFDdkMsNkJBQThCO0FBQzlCLCtCQUFnQztBQUVoQyxnQ0FBOEU7QUFDOUUsZ0VBQXdHO0FBQ3hHLGdEQUFvRDtBQUNwRCxvREFBOEY7QUFDOUYsb0VBQTBHO0FBQzFHLG9EQUFnRDtBQUNoRCxzQ0FBOEM7QUFDOUMsc0NBQXVGO0FBQ3ZGLDRDQUFnRjtBQUNoRiwwQ0FBMkM7QUFDM0MsZ0RBQXNEO0FBQ3RELDhDQUEwRDtBQUMxRCwwQ0FBMkM7QUFFM0Msc0RBQXNEO0FBQ3RELEtBQUssVUFBVSx5QkFBeUI7SUFDdEMsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLDZCQUFzQixDQUFDO0lBQzFELE9BQU8sS0FBSztTQUNULEdBQUcsQ0FBQyxLQUFLLENBQUM7U0FDVixLQUFLLENBQUMsaUNBQWlDLENBQUM7U0FDeEMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUseUdBQXlHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2pMLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDZDQUE2QyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2xJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDhGQUE4RixFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUMvSixNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsZ0NBQWdDLEVBQUUsQ0FBQztTQUM1RSxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsdUNBQXVDLEVBQUUsQ0FBQztTQUNwRixNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSx1RUFBdUUsRUFBRSxDQUFDO1NBQzNJLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLHNFQUFzRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztTQUM3SSxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7U0FDM0YsTUFBTSxDQUFDLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLDBEQUEwRCxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUMxSCxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsNEZBQTRGLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQzFKLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUscUZBQXFGLEVBQUUsQ0FBQztTQUNwSyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSx5RkFBeUYsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLENBQUM7U0FDckssTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLHVGQUF1RixFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUMxSixNQUFNLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxtR0FBbUcsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDdkssTUFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsaURBQWlELEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDbEosTUFBTSxDQUFDLG9CQUFvQixFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsbUNBQW1DLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQzlHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSw2SEFBNkgsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDMUwsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsMEVBQTBFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ3JKLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxvREFBb0QsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7U0FDbkgsT0FBTyxDQUFDLENBQUUsaUJBQWlCLEVBQUUsZUFBZSxDQUFFLEVBQUUsNkJBQTZCLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLO1NBQzNGLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsZ0RBQWdELEVBQUUsQ0FBQyxDQUFDO1NBQzFILE9BQU8sQ0FBQyxDQUFFLHVCQUF1QixFQUFFLGtCQUFrQixDQUFFLEVBQUUsbUVBQW1FLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLO1NBQzFJLE1BQU0sQ0FBQyxhQUFhLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDJEQUEyRCxFQUFFLENBQUMsQ0FBQztTQUM1SCxPQUFPLENBQUMsNEJBQTRCLEVBQUUsdURBQXVELEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLO1NBQzNHLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUMsR0FBRyxFQUFFLHFCQUFxQixDQUFDLEVBQUUsSUFBSSxFQUFFLG9DQUFvQyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsQ0FBQztTQUN4SixNQUFNLENBQUMsc0JBQXNCLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSx1REFBdUQsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLENBQUM7U0FDckksTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsdUNBQXVDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3pJLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRSx5REFBeUQsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUs7U0FDcEcsTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSwwRUFBMEUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUM7U0FDL0osTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsMkRBQTJELEVBQUUsQ0FBQztTQUN6SCxNQUFNLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLHNCQUFlLENBQUMsS0FBSyxFQUFFLHNCQUFlLENBQUMsU0FBUyxFQUFFLHNCQUFlLENBQUMsVUFBVSxDQUFDLEVBQUUsSUFBSSxFQUFFLHNEQUFzRCxFQUFFLENBQUM7U0FDck0sTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLDhEQUE4RCxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxTQUFTLEVBQUUsQ0FBQztTQUM5SSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSw4RUFBOEUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUMsQ0FBQztTQUMvSixNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxzQ0FBc0MsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQzNILE9BQU8sQ0FBQyxvQkFBb0IsRUFBRSxtQ0FBbUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUs7U0FDL0UsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsd0RBQXdELEVBQUUsQ0FBQztTQUN0SCxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSwwREFBMEQsRUFBRSxDQUFDLENBQUM7U0FDckgsT0FBTyxDQUFDLGlCQUFpQixFQUFFLHFJQUFxSSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSztTQUM5SyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSx5REFBeUQsRUFBRSxDQUFDO1NBQ3ZILE1BQU0sQ0FBQyxlQUFlLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxxRUFBcUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUN2SixNQUFNLENBQUMsVUFBVSxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUseURBQXlELEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQzFILE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxnREFBZ0QsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUNoSCxPQUFPLENBQUMsa0JBQWtCLEVBQUUsaURBQWlELENBQUM7U0FDOUUsT0FBTyxDQUFDLGlCQUFpQixFQUFFLDJHQUEyRyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSztTQUNwSixNQUFNLENBQUMsVUFBVSxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSx3RkFBd0YsRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQztTQUNqTCxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsOEJBQThCLEVBQUUsQ0FBQztTQUN6RSxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxnS0FBZ0ssRUFBQyxDQUFDLENBQUM7U0FDdE8sVUFBVSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDO1NBQ2xELE9BQU8sQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDO1NBQ2hDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsa0JBQWtCO1NBQ3ZDLElBQUksRUFBRTtTQUNOLEtBQUssQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDO1NBQ2xCLFFBQVEsQ0FBQztRQUNSLDRFQUE0RTtRQUM1RSxtSUFBbUk7S0FDcEksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDZCxJQUFJLENBQUM7QUFDVixDQUFDO0FBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztDQUNsQjtBQUVELEtBQUssVUFBVSxlQUFlO0lBQzVCLE1BQU0sSUFBSSxHQUFHLE1BQU0seUJBQXlCLEVBQUUsQ0FBQztJQUMvQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDaEIsb0JBQVUsRUFBRSxDQUFDO0tBQ2Q7SUFDRCxlQUFLLENBQUMsc0JBQXNCLEVBQUUsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3ZELGVBQUssQ0FBQyx5QkFBeUIsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUV2QyxNQUFNLEdBQUcsR0FBRyxJQUFJLFNBQUcsQ0FBQztRQUNsQixPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU87UUFDckIsWUFBWSxFQUFFLElBQUksQ0FBQyxLQUFLO1FBQ3hCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtLQUN4QixDQUFDLENBQUM7SUFFSCxNQUFNLGFBQWEsR0FBRyxJQUFJLHdCQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUMsTUFBTSxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFFM0IsTUFBTSxXQUFXLEdBQUcsSUFBSSxrREFBOEIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFFaEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxrQkFBUyxDQUFDO1FBQzlCLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPO1FBQ25DLFlBQVksRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQ25DLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtRQUNuQixhQUFhO1FBQ2IsR0FBRztRQUNILFdBQVcsRUFBRSxrQkFBVztLQUN6QixDQUFDLENBQUM7SUFFSCxrRUFBa0U7SUFDbEUsU0FBUyxXQUFXLENBQUMsR0FBRyxRQUFvQjtRQUMxQyxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ2pDLEtBQUssTUFBTSxNQUFNLElBQUksUUFBUSxFQUFFO1lBQzdCLE1BQU0sT0FBTyxHQUFhLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN2RCxLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sRUFBRTtnQkFDNUIsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU7b0JBQUUsU0FBUztpQkFBRTtnQkFDdkMsZUFBSyxDQUFDLG9CQUFvQixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNoRixtQkFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ2pDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDdEI7U0FDRjtRQUVELFNBQVMsVUFBVSxDQUFDLE1BQWM7WUFDaEMsSUFBSTtnQkFDRixPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDaEM7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDVixlQUFLLENBQUMsNEJBQTRCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQ3RFLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLE1BQU0sRUFBRSxDQUFDLENBQUM7YUFDekQ7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVELFdBQVcsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFcEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV0QiwrREFBK0Q7SUFDL0QsTUFBTSxjQUFjLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFFckUsSUFBSTtRQUNGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjO1lBQ3JDLENBQUMsQ0FBQyxNQUFPLElBQUksQ0FBQyxjQUF1RCxDQUFDLGNBQWMsQ0FBQztZQUNyRixDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFCLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1lBQ25DLE9BQU8sWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ2xDO2FBQU0sSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLEVBQUU7WUFDMUMsT0FBTyxXQUFXLENBQUM7U0FDcEI7YUFBTTtZQUNMLE9BQU8sV0FBVyxDQUFDO1NBQ3BCO0tBQ0Y7WUFBUztRQUNSLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFLENBQUM7S0FDdkM7SUFFRCxLQUFLLFVBQVUsSUFBSSxDQUFDLE9BQWUsRUFBRSxJQUFTO1FBQzVDLE1BQU0sZ0JBQWdCLEdBQVcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLElBQUksOENBQTBCLENBQUM7UUFFaEgsSUFBSSxnQkFBZ0IsS0FBSyw4Q0FBMEIsRUFBRTtZQUNuRCxlQUFLLENBQUMsa0JBQWtCLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDMUQ7UUFFRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUM7UUFFNUMsTUFBTSxHQUFHLEdBQUcsSUFBSSx3QkFBVSxDQUFDLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFFdkQsUUFBUSxPQUFPLEVBQUU7WUFDZixLQUFLLElBQUksQ0FBQztZQUNWLEtBQUssTUFBTTtnQkFDVCxPQUFPLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFFekQsS0FBSyxNQUFNO2dCQUNULE9BQU8sTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDO29CQUNwQixVQUFVLEVBQUUsSUFBSSxDQUFDLE1BQU07b0JBQ3ZCLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztvQkFDN0IsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFRO29CQUMzQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07b0JBQ25CLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWTtpQkFDaEMsQ0FBQyxDQUFDO1lBRUwsS0FBSyxXQUFXO2dCQUNkLE9BQU8sTUFBTSxZQUFZLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFO29CQUMzRSxVQUFVLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxlQUFlLEVBQUUsWUFBWSxDQUFDLENBQUM7b0JBQ3ZFLFFBQVEsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGVBQWUsRUFBRSxVQUFVLENBQUMsQ0FBQztvQkFDbkUsSUFBSSxFQUFFLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQzNDLENBQUMsQ0FBQztZQUVMLEtBQUssUUFBUTtnQkFDWCxPQUFPLE1BQU0sR0FBRyxDQUFDLE1BQU0sQ0FBQztvQkFDdEIsVUFBVSxFQUFFLElBQUksQ0FBQyxNQUFNO29CQUN2QixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7b0JBQzdCLGdCQUFnQjtvQkFDaEIsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO29CQUNyQixnQkFBZ0IsRUFBRSxJQUFJLENBQUMsZ0JBQWdCO29CQUN2QyxlQUFlLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUNoRSxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUU7b0JBQ1gsV0FBVyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUM7b0JBQ2xDLElBQUksRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUMxQyxHQUFHLEVBQUUsR0FBRztpQkFDVCxDQUFDLENBQUM7WUFFTCxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUM7b0JBQ3ZCLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTTtvQkFDdkIsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXO29CQUM3QixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7b0JBQ2pCLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztvQkFDckIsR0FBRyxFQUFFLEdBQUc7aUJBQ1QsQ0FBQyxDQUFDO1lBRUwsS0FBSyxZQUFZLENBQUM7WUFDbEIsS0FBSyxPQUFPO2dCQUNWLE9BQU8sTUFBTSxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFNUQsS0FBSyxVQUFVO2dCQUNiLE9BQU8sTUFBTSxXQUFXLENBQUMsTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFeEQsS0FBSyxNQUFNO2dCQUNULE1BQU0sUUFBUSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFDMUQsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7b0JBQ2IsT0FBTyxNQUFNLDhCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUNoRDtxQkFBTTtvQkFDTCxPQUFPLE1BQU0sY0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztpQkFDeEU7WUFDSCxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxlQUFLLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBRXhDO2dCQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLEdBQUcsT0FBTyxDQUFDLENBQUM7U0FDbEQ7SUFDSCxDQUFDO0lBRUQsS0FBSyxVQUFVLFdBQVcsQ0FBQyxTQUFpQjtRQUMxQyxNQUFNLENBQUMsR0FBRyxNQUFNLFNBQVMsQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDckQsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLFVBQVUsWUFBWSxDQUFDLGdCQUEwQixFQUFFLGdCQUF3QixFQUFFLE9BQTJCLEVBQUUsS0FBZ0M7UUFDN0ksMEJBQTBCO1FBQzFCLEVBQUU7UUFDRiw0R0FBNEc7UUFDNUcsNERBQTREO1FBRTVELE1BQU0sR0FBRyxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUVoRCxNQUFNLFlBQVksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0seUNBQTBCLENBQUMsU0FBUyxFQUFFLGdCQUFnQixFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQywwQ0FBMkIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTlJLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsRUFBRTtZQUN2RCxpQkFBTyxDQUFDLHFDQUFxQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUUsSUFBSTtnQkFDRixNQUFNLE1BQU0sR0FBRyxNQUFNLDBCQUFvQixDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM5RixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQywrQ0FBK0M7b0JBQy9ELENBQUMsQ0FBQyxrQ0FBa0MsQ0FBQztnQkFDbkQsaUJBQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNqRDtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLGVBQUssQ0FBQyw2Q0FBNkMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDdkYsTUFBTSxDQUFDLENBQUM7YUFDVDtRQUNILENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDTixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxLQUFLLFVBQVUsYUFBYSxDQUFDLFFBQWtCLEVBQ2xCLFdBQW9CO1FBQy9DLDJGQUEyRjtRQUMzRixNQUFNLHNCQUFzQixHQUFHLENBQUMsV0FBVyxDQUFDO1FBRTVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sU0FBUyxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUU7WUFDcEQsTUFBTSxFQUFFLHNCQUFzQixDQUFDLENBQUMsQ0FBQywrQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLCtCQUFzQixDQUFDLElBQUk7WUFDOUYsZUFBZSxFQUFFLHlCQUFnQixDQUFDLFNBQVM7U0FDNUMsQ0FBQyxDQUFDO1FBRUgsU0FBUyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVsQyxnREFBZ0Q7UUFDaEQsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7U0FDM0I7UUFFRCwwR0FBMEc7UUFDMUcsd0dBQXdHO1FBQ3hHLCtFQUErRTtRQUMvRSxFQUFFO1FBQ0YseUVBQXlFO1FBQ3pFLHlFQUF5RTtRQUN6RSxrQ0FBa0M7UUFDbEMsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEtBQUssR0FBRyxDQUFDO1FBQ3ZELElBQUksV0FBVyxFQUFFO1lBQ2YsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsc0ZBQXNGO1FBQ3RGLGlCQUFPLENBQUMsK0JBQStCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25HLGVBQUssQ0FBQyxzQkFBc0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBRXhHLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxLQUFLLFVBQVUsT0FBTyxDQUFDLFNBQW1CLEVBQUUsVUFBOEIsRUFBRztRQUMzRSxNQUFNLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLEVBQUUsZUFBZSxFQUFFLHlCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFFeEcsNkRBQTZEO1FBQzdELElBQUksT0FBTyxDQUFDLElBQUksRUFBRTtZQUNoQixNQUFNLElBQUksR0FBRyxFQUFFLENBQUM7WUFDaEIsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxJQUFJLENBQUM7b0JBQ1IsRUFBRSxFQUFFLEtBQUssQ0FBQyxFQUFFO29CQUNaLElBQUksRUFBRSxLQUFLLENBQUMsU0FBUztvQkFDckIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO2lCQUMvQixDQUFDLENBQUM7YUFDSjtZQUNELE9BQU8sSUFBSSxDQUFDLENBQUMsZ0NBQWdDO1NBQzlDO1FBRUQsdUJBQXVCO1FBQ3ZCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1lBQzFCLGNBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEI7UUFFRCxPQUFPLENBQUMsQ0FBQyxDQUFDLFlBQVk7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxVQUFVLFNBQVMsQ0FBQyxVQUFrQjtRQUN6QyxNQUFNLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN4RCxNQUFNLEVBQUUsK0JBQXNCLENBQUMsSUFBSTtZQUNuQyxlQUFlLEVBQUUseUJBQWdCLENBQUMsSUFBSTtTQUN2QyxDQUFDLENBQUM7UUFFSCxtRUFBbUU7UUFDbkUsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLHlFQUF5RSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNuSDtRQUVELE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQsU0FBUyxZQUFZLENBQUMsTUFBVztRQUMvQixPQUFPLDhCQUFrQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0MsQ0FBQztBQUNILENBQUM7QUFFRCxlQUFlLEVBQUU7S0FDZCxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDWixJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7UUFBRSxPQUFPO0tBQUU7SUFDOUIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsY0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ2I7U0FBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUNwQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3JCO0FBQ0gsQ0FBQyxDQUFDO0tBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0lBQ1gsZUFBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQixlQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG5pbXBvcnQgJ3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3Rlcic7XG5cbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5pbXBvcnQgeWFyZ3MgPSByZXF1aXJlKCd5YXJncycpO1xuXG5pbXBvcnQgeyBib290c3RyYXBFbnZpcm9ubWVudCwgQm9vdHN0cmFwRW52aXJvbm1lbnRQcm9wcywgU0RLIH0gZnJvbSAnLi4vbGliJztcbmltcG9ydCB7IGVudmlyb25tZW50c0Zyb21EZXNjcmlwdG9ycywgZ2xvYkVudmlyb25tZW50c0Zyb21TdGFja3MgfSBmcm9tICcuLi9saWIvYXBpL2N4YXBwL2Vudmlyb25tZW50cyc7XG5pbXBvcnQgeyBleGVjUHJvZ3JhbSB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvZXhlYyc7XG5pbXBvcnQgeyBBcHBTdGFja3MsIERlZmF1bHRTZWxlY3Rpb24sIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24gfSBmcm9tICcuLi9saWIvYXBpL2N4YXBwL3N0YWNrcyc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbkRlcGxveW1lbnRUYXJnZXQsIERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FIH0gZnJvbSAnLi4vbGliL2FwaS9kZXBsb3ltZW50LXRhcmdldCc7XG5pbXBvcnQgeyBDZGtUb29sa2l0IH0gZnJvbSAnLi4vbGliL2Nkay10b29sa2l0JztcbmltcG9ydCB7IFJlcXVpcmVBcHByb3ZhbCB9IGZyb20gJy4uL2xpYi9kaWZmJztcbmltcG9ydCB7IGF2YWlsYWJsZUluaXRMYW5ndWFnZXMsIGNsaUluaXQsIHByaW50QXZhaWxhYmxlVGVtcGxhdGVzIH0gZnJvbSAnLi4vbGliL2luaXQnO1xuaW1wb3J0IHsgZGF0YSwgZGVidWcsIGVycm9yLCBwcmludCwgc2V0VmVyYm9zZSwgc3VjY2VzcyB9IGZyb20gJy4uL2xpYi9sb2dnaW5nJztcbmltcG9ydCB7IFBsdWdpbkhvc3QgfSBmcm9tICcuLi9saWIvcGx1Z2luJztcbmltcG9ydCB7IHNlcmlhbGl6ZVN0cnVjdHVyZSB9IGZyb20gJy4uL2xpYi9zZXJpYWxpemUnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiwgU2V0dGluZ3MgfSBmcm9tICcuLi9saWIvc2V0dGluZ3MnO1xuaW1wb3J0IHZlcnNpb24gPSByZXF1aXJlKCcuLi9saWIvdmVyc2lvbicpO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1zaGFkb3dlZC12YXJpYWJsZSBtYXgtbGluZS1sZW5ndGhcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tbWFuZExpbmVBcmd1bWVudHMoKSB7XG4gIGNvbnN0IGluaXRUZW1wbGF0ZUxhbnVhZ2VzID0gYXdhaXQgYXZhaWxhYmxlSW5pdExhbmd1YWdlcztcbiAgcmV0dXJuIHlhcmdzXG4gICAgLmVudignQ0RLJylcbiAgICAudXNhZ2UoJ1VzYWdlOiBjZGsgLWEgPGNkay1hcHA+IENPTU1BTkQnKVxuICAgIC5vcHRpb24oJ2FwcCcsIHsgdHlwZTogJ3N0cmluZycsIGFsaWFzOiAnYScsIGRlc2M6ICdSRVFVSVJFRDogY29tbWFuZC1saW5lIGZvciBleGVjdXRpbmcgeW91ciBhcHAgb3IgYSBjbG91ZCBhc3NlbWJseSBkaXJlY3RvcnkgKGUuZy4gXCJub2RlIGJpbi9teS1hcHAuanNcIiknLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ2NvbnRleHQnLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAnYycsIGRlc2M6ICdBZGQgY29udGV4dHVhbCBzdHJpbmcgcGFyYW1ldGVyIChLRVk9VkFMVUUpJywgbmFyZ3M6IDEsIHJlcXVpcmVzQXJnOiB0cnVlIH0pXG4gICAgLm9wdGlvbigncGx1Z2luJywgeyB0eXBlOiAnYXJyYXknLCBhbGlhczogJ3AnLCBkZXNjOiAnTmFtZSBvciBwYXRoIG9mIGEgbm9kZSBwYWNrYWdlIHRoYXQgZXh0ZW5kIHRoZSBDREsgZmVhdHVyZXMuIENhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMnLCBuYXJnczogMSB9KVxuICAgIC5vcHRpb24oJ3RyYWNlJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdQcmludCB0cmFjZSBmb3Igc3RhY2sgd2FybmluZ3MnIH0pXG4gICAgLm9wdGlvbignc3RyaWN0JywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdEbyBub3QgY29uc3RydWN0IHN0YWNrcyB3aXRoIHdhcm5pbmdzJyB9KVxuICAgIC5vcHRpb24oJ2lnbm9yZS1lcnJvcnMnLCB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UsIGRlc2M6ICdJZ25vcmVzIHN5bnRoZXNpcyBlcnJvcnMsIHdoaWNoIHdpbGwgbGlrZWx5IHByb2R1Y2UgYW4gaW52YWxpZCBvdXRwdXQnIH0pXG4gICAgLm9wdGlvbignanNvbicsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2onLCBkZXNjOiAnVXNlIEpTT04gb3V0cHV0IGluc3RlYWQgb2YgWUFNTCB3aGVuIHRlbXBsYXRlcyBhcmUgcHJpbnRlZCB0byBTVERPVVQnLCBkZWZhdWx0OiBmYWxzZSB9KVxuICAgIC5vcHRpb24oJ3ZlcmJvc2UnLCB7IHR5cGU6ICdib29sZWFuJywgYWxpYXM6ICd2JywgZGVzYzogJ1Nob3cgZGVidWcgbG9ncycsIGRlZmF1bHQ6IGZhbHNlIH0pXG4gICAgLm9wdGlvbigncHJvZmlsZScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdVc2UgdGhlIGluZGljYXRlZCBBV1MgcHJvZmlsZSBhcyB0aGUgZGVmYXVsdCBlbnZpcm9ubWVudCcsIHJlcXVpcmVzQXJnOiB0cnVlIH0pXG4gICAgLm9wdGlvbigncHJveHknLCB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjOiAnVXNlIHRoZSBpbmRpY2F0ZWQgcHJveHkuIFdpbGwgcmVhZCBmcm9tIEhUVFBTX1BST1hZIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIG5vdCBzcGVjaWZpZWQuJywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdlYzJjcmVkcycsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2knLCBkZWZhdWx0OiB1bmRlZmluZWQsIGRlc2M6ICdGb3JjZSB0cnlpbmcgdG8gZmV0Y2ggRUMyIGluc3RhbmNlIGNyZWRlbnRpYWxzLiBEZWZhdWx0OiBndWVzcyBFQzIgaW5zdGFuY2Ugc3RhdHVzLicgfSlcbiAgICAub3B0aW9uKCd2ZXJzaW9uLXJlcG9ydGluZycsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnSW5jbHVkZSB0aGUgXCJBV1M6OkNESzo6TWV0YWRhdGFcIiByZXNvdXJjZSBpbiBzeW50aGVzaXplZCB0ZW1wbGF0ZXMgKGVuYWJsZWQgYnkgZGVmYXVsdCknLCBkZWZhdWx0OiB1bmRlZmluZWQgfSlcbiAgICAub3B0aW9uKCdwYXRoLW1ldGFkYXRhJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdJbmNsdWRlIFwiYXdzOmNkazpwYXRoXCIgQ2xvdWRGb3JtYXRpb24gbWV0YWRhdGEgZm9yIGVhY2ggcmVzb3VyY2UgKGVuYWJsZWQgYnkgZGVmYXVsdCknLCBkZWZhdWx0OiB0cnVlIH0pXG4gICAgLm9wdGlvbignYXNzZXQtbWV0YWRhdGEnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0luY2x1ZGUgXCJhd3M6YXNzZXQ6KlwiIENsb3VkRm9ybWF0aW9uIG1ldGFkYXRhIGZvciByZXNvdXJjZXMgdGhhdCB1c2VyIGFzc2V0cyAoZW5hYmxlZCBieSBkZWZhdWx0KScsIGRlZmF1bHQ6IHRydWUgfSlcbiAgICAub3B0aW9uKCdyb2xlLWFybicsIHsgdHlwZTogJ3N0cmluZycsIGFsaWFzOiAncicsIGRlc2M6ICdBUk4gb2YgUm9sZSB0byB1c2Ugd2hlbiBpbnZva2luZyBDbG91ZEZvcm1hdGlvbicsIGRlZmF1bHQ6IHVuZGVmaW5lZCwgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCd0b29sa2l0LXN0YWNrLW5hbWUnLCB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjOiAnVGhlIG5hbWUgb2YgdGhlIENESyB0b29sa2l0IHN0YWNrJywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdzdGFnaW5nJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdDb3B5IGFzc2V0cyB0byB0aGUgb3V0cHV0IGRpcmVjdG9yeSAodXNlIC0tbm8tc3RhZ2luZyB0byBkaXNhYmxlLCBuZWVkZWQgZm9yIGxvY2FsIGRlYnVnZ2luZyB0aGUgc291cmNlIGZpbGVzIHdpdGggU0FNIENMSSknLCBkZWZhdWx0OiB0cnVlIH0pXG4gICAgLm9wdGlvbignb3V0cHV0JywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdvJywgZGVzYzogJ0VtaXRzIHRoZSBzeW50aGVzaXplZCBjbG91ZCBhc3NlbWJseSBpbnRvIGEgZGlyZWN0b3J5IChkZWZhdWx0OiBjZGsub3V0KScsIHJlcXVpcmVzQXJnOiB0cnVlIH0pXG4gICAgLm9wdGlvbignbm8tY29sb3InLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ1JlbW92ZXMgY29sb3JzIGFuZCBvdGhlciBzdHlsZSBmcm9tIGNvbnNvbGUgb3V0cHV0JywgZGVmYXVsdDogZmFsc2UgfSlcbiAgICAuY29tbWFuZChbICdsaXN0IFtTVEFDS1MuLl0nLCAnbHMgW1NUQUNLUy4uXScgXSwgJ0xpc3RzIGFsbCBzdGFja3MgaW4gdGhlIGFwcCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdsb25nJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlLCBhbGlhczogJ2wnLCBkZXNjOiAnRGlzcGxheSBlbnZpcm9ubWVudCBpbmZvcm1hdGlvbiBmb3IgZWFjaCBzdGFjaycgfSkpXG4gICAgLmNvbW1hbmQoWyAnc3ludGhlc2l6ZSBbU1RBQ0tTLi5dJywgJ3N5bnRoIFtTVEFDS1MuLl0nIF0sICdTeW50aGVzaXplcyBhbmQgcHJpbnRzIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBmb3IgdGhpcyBzdGFjaycsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdleGNsdXNpdmVseScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2UnLCBkZXNjOiAnT25seSBkZXBsb3kgcmVxdWVzdGVkIHN0YWNrcywgZG9uXFwndCBpbmNsdWRlIGRlcGVuZGVuY2llcycgfSkpXG4gICAgLmNvbW1hbmQoJ2Jvb3RzdHJhcCBbRU5WSVJPTk1FTlRTLi5dJywgJ0RlcGxveXMgdGhlIENESyB0b29sa2l0IHN0YWNrIGludG8gYW4gQVdTIGVudmlyb25tZW50JywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2Jvb3RzdHJhcC1idWNrZXQtbmFtZScsIHsgdHlwZTogJ3N0cmluZycsIGFsaWFzOiBbJ2InLCAndG9vbGtpdC1idWNrZXQtbmFtZSddLCBkZXNjOiAnVGhlIG5hbWUgb2YgdGhlIENESyB0b29sa2l0IGJ1Y2tldCcsIGRlZmF1bHQ6IHVuZGVmaW5lZCB9KVxuICAgICAgLm9wdGlvbignYm9vdHN0cmFwLWttcy1rZXktaWQnLCB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjOiAnQVdTIEtNUyBtYXN0ZXIga2V5IElEIHVzZWQgZm9yIHRoZSBTU0UtS01TIGVuY3J5cHRpb24nLCBkZWZhdWx0OiB1bmRlZmluZWQgfSlcbiAgICAgIC5vcHRpb24oJ3RhZ3MnLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAndCcsIGRlc2M6ICdUYWdzIHRvIGFkZCBmb3IgdGhlIHN0YWNrIChLRVk9VkFMVUUpJywgbmFyZ3M6IDEsIHJlcXVpcmVzQXJnOiB0cnVlLCBkZWZhdWx0OiBbXSB9KSlcbiAgICAuY29tbWFuZCgnZGVwbG95IFtTVEFDS1MuLl0nLCAnRGVwbG95cyB0aGUgc3RhY2socykgbmFtZWQgU1RBQ0tTIGludG8geW91ciBBV1MgYWNjb3VudCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdidWlsZC1leGNsdWRlJywgeyB0eXBlOiAnYXJyYXknLCBhbGlhczogJ0UnLCBuYXJnczogMSwgZGVzYzogJ0RvIG5vdCByZWJ1aWxkIGFzc2V0IHdpdGggdGhlIGdpdmVuIElELiBDYW4gYmUgc3BlY2lmaWVkIG11bHRpcGxlIHRpbWVzLicsIGRlZmF1bHQ6IFtdIH0pXG4gICAgICAub3B0aW9uKCdleGNsdXNpdmVseScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2UnLCBkZXNjOiAnT25seSBkZXBsb3kgcmVxdWVzdGVkIHN0YWNrcywgZG9uXFwndCBpbmNsdWRlIGRlcGVuZGVuY2llcycgfSlcbiAgICAgIC5vcHRpb24oJ3JlcXVpcmUtYXBwcm92YWwnLCB7IHR5cGU6ICdzdHJpbmcnLCBjaG9pY2VzOiBbUmVxdWlyZUFwcHJvdmFsLk5ldmVyLCBSZXF1aXJlQXBwcm92YWwuQW55Q2hhbmdlLCBSZXF1aXJlQXBwcm92YWwuQnJvYWRlbmluZ10sIGRlc2M6ICdXaGF0IHNlY3VyaXR5LXNlbnNpdGl2ZSBjaGFuZ2VzIG5lZWQgbWFudWFsIGFwcHJvdmFsJyB9KVxuICAgICAgLm9wdGlvbignY2knLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0ZvcmNlIENJIGRldGVjdGlvbi4gVXNlIC0tbm8tY2kgdG8gZGlzYWJsZSBDSSBhdXRvZGV0ZWN0aW9uLicsIGRlZmF1bHQ6IHByb2Nlc3MuZW52LkNJICE9PSB1bmRlZmluZWQgfSlcbiAgICAgIC5vcHRpb24oJ25vdGlmaWNhdGlvbi1hcm5zJywge3R5cGU6ICdhcnJheScsIGRlc2M6ICdBUk5zIG9mIFNOUyB0b3BpY3MgdGhhdCBDbG91ZEZvcm1hdGlvbiB3aWxsIG5vdGlmeSB3aXRoIHN0YWNrIHJlbGF0ZWQgZXZlbnRzJywgbmFyZ3M6IDEsIHJlcXVpcmVzQXJnOiB0cnVlfSlcbiAgICAgIC5vcHRpb24oJ3RhZ3MnLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAndCcsIGRlc2M6ICdUYWdzIHRvIGFkZCB0byB0aGUgc3RhY2sgKEtFWT1WQUxVRSknLCBuYXJnczogMSwgcmVxdWlyZXNBcmc6IHRydWUgfSkpXG4gICAgLmNvbW1hbmQoJ2Rlc3Ryb3kgW1NUQUNLUy4uXScsICdEZXN0cm95IHRoZSBzdGFjayhzKSBuYW1lZCBTVEFDS1MnLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignZXhjbHVzaXZlbHknLCB7IHR5cGU6ICdib29sZWFuJywgYWxpYXM6ICdlJywgZGVzYzogJ09ubHkgZGVwbG95IHJlcXVlc3RlZCBzdGFja3MsIGRvblxcJ3QgaW5jbHVkZSBkZXBlbmRlZXMnIH0pXG4gICAgICAub3B0aW9uKCdmb3JjZScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2YnLCBkZXNjOiAnRG8gbm90IGFzayBmb3IgY29uZmlybWF0aW9uIGJlZm9yZSBkZXN0cm95aW5nIHRoZSBzdGFja3MnIH0pKVxuICAgIC5jb21tYW5kKCdkaWZmIFtTVEFDS1MuLl0nLCAnQ29tcGFyZXMgdGhlIHNwZWNpZmllZCBzdGFjayB3aXRoIHRoZSBkZXBsb3llZCBzdGFjayBvciBhIGxvY2FsIHRlbXBsYXRlIGZpbGUsIGFuZCByZXR1cm5zIHdpdGggc3RhdHVzIDEgaWYgYW55IGRpZmZlcmVuY2UgaXMgZm91bmQnLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignZXhjbHVzaXZlbHknLCB7IHR5cGU6ICdib29sZWFuJywgYWxpYXM6ICdlJywgZGVzYzogJ09ubHkgZGlmZiByZXF1ZXN0ZWQgc3RhY2tzLCBkb25cXCd0IGluY2x1ZGUgZGVwZW5kZW5jaWVzJyB9KVxuICAgICAgLm9wdGlvbignY29udGV4dC1saW5lcycsIHsgdHlwZTogJ251bWJlcicsIGRlc2M6ICdOdW1iZXIgb2YgY29udGV4dCBsaW5lcyB0byBpbmNsdWRlIGluIGFyYml0cmFyeSBKU09OIGRpZmYgcmVuZGVyaW5nJywgZGVmYXVsdDogMywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAgIC5vcHRpb24oJ3RlbXBsYXRlJywgeyB0eXBlOiAnc3RyaW5nJywgZGVzYzogJ1RoZSBwYXRoIHRvIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSB0byBjb21wYXJlIHdpdGgnLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgICAgLm9wdGlvbignc3RyaWN0JywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdEbyBub3QgZmlsdGVyIG91dCBBV1M6OkNESzo6TWV0YWRhdGEgcmVzb3VyY2VzJywgZGVmYXVsdDogZmFsc2UgfSkpXG4gICAgLmNvbW1hbmQoJ21ldGFkYXRhIFtTVEFDS10nLCAnUmV0dXJucyBhbGwgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhY2snKVxuICAgIC5jb21tYW5kKCdpbml0IFtURU1QTEFURV0nLCAnQ3JlYXRlIGEgbmV3LCBlbXB0eSBDREsgcHJvamVjdCBmcm9tIGEgdGVtcGxhdGUuIEludm9rZWQgd2l0aG91dCBURU1QTEFURSwgdGhlIGFwcCB0ZW1wbGF0ZSB3aWxsIGJlIHVzZWQuJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2xhbmd1YWdlJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdsJywgZGVzYzogJ1RoZSBsYW5ndWFnZSB0byBiZSB1c2VkIGZvciB0aGUgbmV3IHByb2plY3QgKGRlZmF1bHQgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gfi8uY2RrLmpzb24pJywgY2hvaWNlczogaW5pdFRlbXBsYXRlTGFudWFnZXMgfSlcbiAgICAgIC5vcHRpb24oJ2xpc3QnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0xpc3QgdGhlIGF2YWlsYWJsZSB0ZW1wbGF0ZXMnIH0pXG4gICAgICAub3B0aW9uKCdnZW5lcmF0ZS1vbmx5JywgeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlLCBkZXNjOiAnSWYgdHJ1ZSwgb25seSBnZW5lcmF0ZXMgcHJvamVjdCBmaWxlcywgd2l0aG91dCBleGVjdXRpbmcgYWRkaXRpb25hbCBvcGVyYXRpb25zIHN1Y2ggYXMgc2V0dGluZyB1cCBhIGdpdCByZXBvLCBpbnN0YWxsaW5nIGRlcGVuZGVuY2llcyBvciBjb21waWxpbmcgdGhlIHByb2plY3QnfSkpXG4gICAgLmNvbW1hbmREaXIoJy4uL2xpYi9jb21tYW5kcycsIHsgZXhjbHVkZTogL15fLiovIH0pXG4gICAgLnZlcnNpb24odmVyc2lvbi5ESVNQTEFZX1ZFUlNJT04pXG4gICAgLmRlbWFuZENvbW1hbmQoMSwgJycpIC8vIGp1c3QgcHJpbnQgaGVscFxuICAgIC5oZWxwKClcbiAgICAuYWxpYXMoJ2gnLCAnaGVscCcpXG4gICAgLmVwaWxvZ3VlKFtcbiAgICAgICdJZiB5b3VyIGFwcCBoYXMgYSBzaW5nbGUgc3RhY2ssIHRoZXJlIGlzIG5vIG5lZWQgdG8gc3BlY2lmeSB0aGUgc3RhY2sgbmFtZScsXG4gICAgICAnSWYgb25lIG9mIGNkay5qc29uIG9yIH4vLmNkay5qc29uIGV4aXN0cywgb3B0aW9ucyBzcGVjaWZpZWQgdGhlcmUgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHRzLiBTZXR0aW5ncyBpbiBjZGsuanNvbiB0YWtlIHByZWNlZGVuY2UuJ1xuICAgIF0uam9pbignXFxuXFxuJykpXG4gICAgLmFyZ3Y7XG59XG5cbmlmICghcHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgY29sb3JzLmRpc2FibGUoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdENvbW1hbmRMaW5lKCkge1xuICBjb25zdCBhcmd2ID0gYXdhaXQgcGFyc2VDb21tYW5kTGluZUFyZ3VtZW50cygpO1xuICBpZiAoYXJndi52ZXJib3NlKSB7XG4gICAgc2V0VmVyYm9zZSgpO1xuICB9XG4gIGRlYnVnKCdDREsgdG9vbGtpdCB2ZXJzaW9uOicsIHZlcnNpb24uRElTUExBWV9WRVJTSU9OKTtcbiAgZGVidWcoJ0NvbW1hbmQgbGluZSBhcmd1bWVudHM6JywgYXJndik7XG5cbiAgY29uc3QgYXdzID0gbmV3IFNESyh7XG4gICAgcHJvZmlsZTogYXJndi5wcm9maWxlLFxuICAgIHByb3h5QWRkcmVzczogYXJndi5wcm94eSxcbiAgICBlYzJjcmVkczogYXJndi5lYzJjcmVkcyxcbiAgfSk7XG5cbiAgY29uc3QgY29uZmlndXJhdGlvbiA9IG5ldyBDb25maWd1cmF0aW9uKGFyZ3YpO1xuICBhd2FpdCBjb25maWd1cmF0aW9uLmxvYWQoKTtcblxuICBjb25zdCBwcm92aXNpb25lciA9IG5ldyBDbG91ZEZvcm1hdGlvbkRlcGxveW1lbnRUYXJnZXQoeyBhd3MgfSk7XG5cbiAgY29uc3QgYXBwU3RhY2tzID0gbmV3IEFwcFN0YWNrcyh7XG4gICAgdmVyYm9zZTogYXJndi50cmFjZSB8fCBhcmd2LnZlcmJvc2UsXG4gICAgaWdub3JlRXJyb3JzOiBhcmd2WydpZ25vcmUtZXJyb3JzJ10sXG4gICAgc3RyaWN0OiBhcmd2LnN0cmljdCxcbiAgICBjb25maWd1cmF0aW9uLFxuICAgIGF3cyxcbiAgICBzeW50aGVzaXplcjogZXhlY1Byb2dyYW0sXG4gIH0pO1xuXG4gIC8qKiBGdW5jdGlvbiB0byBsb2FkIHBsdWctaW5zLCB1c2luZyBjb25maWd1cmF0aW9ucyBhZGRpdGl2ZWx5LiAqL1xuICBmdW5jdGlvbiBsb2FkUGx1Z2lucyguLi5zZXR0aW5nczogU2V0dGluZ3NbXSkge1xuICAgIGNvbnN0IGxvYWRlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNldHRpbmdzKSB7XG4gICAgICBjb25zdCBwbHVnaW5zOiBzdHJpbmdbXSA9IHNvdXJjZS5nZXQoWydwbHVnaW4nXSkgfHwgW107XG4gICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gdHJ5UmVzb2x2ZShwbHVnaW4pO1xuICAgICAgICBpZiAobG9hZGVkLmhhcyhyZXNvbHZlZCkpIHsgY29udGludWU7IH1cbiAgICAgICAgZGVidWcoYExvYWRpbmcgcGx1Zy1pbjogJHtjb2xvcnMuZ3JlZW4ocGx1Z2luKX0gZnJvbSAke2NvbG9ycy5ibHVlKHJlc29sdmVkKX1gKTtcbiAgICAgICAgUGx1Z2luSG9zdC5pbnN0YW5jZS5sb2FkKHBsdWdpbik7XG4gICAgICAgIGxvYWRlZC5hZGQocmVzb2x2ZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeVJlc29sdmUocGx1Z2luOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUucmVzb2x2ZShwbHVnaW4pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgcGx1Z2luICR7Y29sb3JzLmdyZWVuKHBsdWdpbil9OiAke2Uuc3RhY2t9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgcGx1Zy1pbjogJHtwbHVnaW59YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZFBsdWdpbnMoY29uZmlndXJhdGlvbi5zZXR0aW5ncyk7XG5cbiAgY29uc3QgY21kID0gYXJndi5fWzBdO1xuXG4gIC8vIEJ1bmRsZSB1cCBnbG9iYWwgb2JqZWN0cyBzbyB0aGUgY29tbWFuZHMgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICBjb25zdCBjb21tYW5kT3B0aW9ucyA9IHsgYXJnczogYXJndiwgYXBwU3RhY2tzLCBjb25maWd1cmF0aW9uLCBhd3MgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXJndi5jb21tYW5kSGFuZGxlclxuICAgICAgPyBhd2FpdCAoYXJndi5jb21tYW5kSGFuZGxlciBhcyAob3B0czogdHlwZW9mIGNvbW1hbmRPcHRpb25zKSA9PiBhbnkpKGNvbW1hbmRPcHRpb25zKVxuICAgICAgOiBhd2FpdCBtYWluKGNtZCwgYXJndik7XG4gICAgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0b0pzb25PcllhbWwocmV0dXJuVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJldHVyblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IHZlcnNpb24uZGlzcGxheVZlcnNpb25NZXNzYWdlKCk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBtYWluKGNvbW1hbmQ6IHN0cmluZywgYXJnczogYW55KTogUHJvbWlzZTxudW1iZXIgfCBzdHJpbmcgfCB7fSB8IHZvaWQ+IHtcbiAgICBjb25zdCB0b29sa2l0U3RhY2tOYW1lOiBzdHJpbmcgPSBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3Rvb2xraXRTdGFja05hbWUnXSkgfHwgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG5cbiAgICBpZiAodG9vbGtpdFN0YWNrTmFtZSAhPT0gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUpIHtcbiAgICAgIHByaW50KGBUb29sa2l0IHN0YWNrOiAke2NvbG9ycy5ib2xkKHRvb2xraXRTdGFja05hbWUpfWApO1xuICAgIH1cblxuICAgIGFyZ3MuU1RBQ0tTID0gYXJncy5TVEFDS1MgfHwgW107XG4gICAgYXJncy5FTlZJUk9OTUVOVFMgPSBhcmdzLkVOVklST05NRU5UUyB8fCBbXTtcblxuICAgIGNvbnN0IGNsaSA9IG5ldyBDZGtUb29sa2l0KHsgYXBwU3RhY2tzLCBwcm92aXNpb25lciB9KTtcblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnbHMnOlxuICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGlMaXN0KGFyZ3MuU1RBQ0tTLCB7IGxvbmc6IGFyZ3MubG9uZyB9KTtcblxuICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGkuZGlmZih7XG4gICAgICAgICAgc3RhY2tOYW1lczogYXJncy5TVEFDS1MsXG4gICAgICAgICAgZXhjbHVzaXZlbHk6IGFyZ3MuZXhjbHVzaXZlbHksXG4gICAgICAgICAgdGVtcGxhdGVQYXRoOiBhcmdzLnRlbXBsYXRlLFxuICAgICAgICAgIHN0cmljdDogYXJncy5zdHJpY3QsXG4gICAgICAgICAgY29udGV4dExpbmVzOiBhcmdzLmNvbnRleHRMaW5lc1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYm9vdHN0cmFwJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaUJvb3RzdHJhcChhcmdzLkVOVklST05NRU5UUywgdG9vbGtpdFN0YWNrTmFtZSwgYXJncy5yb2xlQXJuLCB7XG4gICAgICAgICAgYnVja2V0TmFtZTogY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd0b29sa2l0QnVja2V0JywgJ2J1Y2tldE5hbWUnXSksXG4gICAgICAgICAga21zS2V5SWQ6IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndG9vbGtpdEJ1Y2tldCcsICdrbXNLZXlJZCddKSxcbiAgICAgICAgICB0YWdzOiBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3RhZ3MnXSlcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2RlcGxveSc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGkuZGVwbG95KHtcbiAgICAgICAgICBzdGFja05hbWVzOiBhcmdzLlNUQUNLUyxcbiAgICAgICAgICBleGNsdXNpdmVseTogYXJncy5leGNsdXNpdmVseSxcbiAgICAgICAgICB0b29sa2l0U3RhY2tOYW1lLFxuICAgICAgICAgIHJvbGVBcm46IGFyZ3Mucm9sZUFybixcbiAgICAgICAgICBub3RpZmljYXRpb25Bcm5zOiBhcmdzLm5vdGlmaWNhdGlvbkFybnMsXG4gICAgICAgICAgcmVxdWlyZUFwcHJvdmFsOiBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3JlcXVpcmVBcHByb3ZhbCddKSxcbiAgICAgICAgICBjaTogYXJncy5jaSxcbiAgICAgICAgICByZXVzZUFzc2V0czogYXJnc1snYnVpbGQtZXhjbHVkZSddLFxuICAgICAgICAgIHRhZ3M6IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndGFncyddKSxcbiAgICAgICAgICBzZGs6IGF3cyxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpLmRlc3Ryb3koe1xuICAgICAgICAgIHN0YWNrTmFtZXM6IGFyZ3MuU1RBQ0tTLFxuICAgICAgICAgIGV4Y2x1c2l2ZWx5OiBhcmdzLmV4Y2x1c2l2ZWx5LFxuICAgICAgICAgIGZvcmNlOiBhcmdzLmZvcmNlLFxuICAgICAgICAgIHJvbGVBcm46IGFyZ3Mucm9sZUFybixcbiAgICAgICAgICBzZGs6IGF3cyxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ3N5bnRoZXNpemUnOlxuICAgICAgY2FzZSAnc3ludGgnOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpU3ludGhlc2l6ZShhcmdzLlNUQUNLUywgYXJncy5leGNsdXNpdmVseSk7XG5cbiAgICAgIGNhc2UgJ21ldGFkYXRhJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaU1ldGFkYXRhKGF3YWl0IGZpbmRTdGFjayhhcmdzLlNUQUNLKSk7XG5cbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsnbGFuZ3VhZ2UnXSk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlT25seSA9IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsnZ2VuZXJhdGUtb25seSddKTtcbiAgICAgICAgaWYgKGFyZ3MubGlzdCkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBwcmludEF2YWlsYWJsZVRlbXBsYXRlcyhsYW5ndWFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGNsaUluaXQoYXJncy5URU1QTEFURSwgbGFuZ3VhZ2UsIHVuZGVmaW5lZCwgZ2VuZXJhdGVPbmx5KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAndmVyc2lvbic6XG4gICAgICAgIHJldHVybiBwcmludCh2ZXJzaW9uLkRJU1BMQVlfVkVSU0lPTik7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb21tYW5kOiAnICsgY29tbWFuZCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2xpTWV0YWRhdGEoc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzID0gYXdhaXQgYXBwU3RhY2tzLnN5bnRoZXNpemVTdGFjayhzdGFja05hbWUpO1xuICAgIHJldHVybiBzLm1hbmlmZXN0Lm1ldGFkYXRhIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJvb3RzdHJhcCB0aGUgQ0RLIFRvb2xraXQgc3RhY2sgaW4gdGhlIGFjY291bnRzIHVzZWQgYnkgdGhlIHNwZWNpZmllZCBzdGFjayhzKS5cbiAgICpcbiAgICogQHBhcmFtIGVudmlyb25tZW50R2xvYnMgZW52aXJvbm1lbnQgbmFtZXMgdGhhdCBuZWVkIHRvIGhhdmUgdG9vbGtpdCBzdXBwb3J0XG4gICAqICAgICAgICAgICAgIHByb3Zpc2lvbmVkLCBhcyBhIGdsb2IgZmlsdGVyLiBJZiBub25lIGlzIHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICBhbGwgc3RhY2tzIGFyZSBpbXBsaWNpdGx5IHNlbGVjdGVkLlxuICAgKiBAcGFyYW0gdG9vbGtpdFN0YWNrTmFtZSB0aGUgbmFtZSB0byBiZSB1c2VkIGZvciB0aGUgQ0RLIFRvb2xraXQgc3RhY2suXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBjbGlCb290c3RyYXAoZW52aXJvbm1lbnRHbG9iczogc3RyaW5nW10sIHRvb2xraXRTdGFja05hbWU6IHN0cmluZywgcm9sZUFybjogc3RyaW5nIHwgdW5kZWZpbmVkLCBwcm9wczogQm9vdHN0cmFwRW52aXJvbm1lbnRQcm9wcyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFR3byBtb2RlcyBvZiBvcGVyYXRpb24uXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiAnLS1hcHAnIGFyZ3VtZW50LCB3ZSBzZWxlY3QgdGhlIGVudmlyb25tZW50cyBmcm9tIHRoZSBhcHAuIE90aGVyd2lzZSB3ZSBqdXN0IHRha2UgdGhlIHVzZXJcbiAgICAvLyBhdCB0aGVpciB3b3JkIHRoYXQgdGhleSBrbm93IHRoZSBuYW1lIG9mIHRoZSBlbnZpcm9ubWVudC5cblxuICAgIGNvbnN0IGFwcCA9IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsnYXBwJ10pO1xuXG4gICAgY29uc3QgZW52aXJvbm1lbnRzID0gYXBwID8gYXdhaXQgZ2xvYkVudmlyb25tZW50c0Zyb21TdGFja3MoYXBwU3RhY2tzLCBlbnZpcm9ubWVudEdsb2JzLCBhd3MpIDogZW52aXJvbm1lbnRzRnJvbURlc2NyaXB0b3JzKGVudmlyb25tZW50R2xvYnMpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZW52aXJvbm1lbnRzLm1hcChhc3luYyAoZW52aXJvbm1lbnQpID0+IHtcbiAgICAgIHN1Y2Nlc3MoJyDij7MgIEJvb3RzdHJhcHBpbmcgZW52aXJvbm1lbnQgJXMuLi4nLCBjb2xvcnMuYmx1ZShlbnZpcm9ubWVudC5uYW1lKSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBib290c3RyYXBFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgYXdzLCB0b29sa2l0U3RhY2tOYW1lLCByb2xlQXJuLCBwcm9wcyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXN1bHQubm9PcCA/ICcg4pyFICBFbnZpcm9ubWVudCAlcyBib290c3RyYXBwZWQgKG5vIGNoYW5nZXMpLidcbiAgICAgICAgICAgICAgICAgICAgICA6ICcg4pyFICBFbnZpcm9ubWVudCAlcyBib290c3RyYXBwZWQuJztcbiAgICAgICAgc3VjY2VzcyhtZXNzYWdlLCBjb2xvcnMuYmx1ZShlbnZpcm9ubWVudC5uYW1lKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKCcg4p2MICBFbnZpcm9ubWVudCAlcyBmYWlsZWQgYm9vdHN0cmFwcGluZzogJXMnLCBjb2xvcnMuYmx1ZShlbnZpcm9ubWVudC5uYW1lKSwgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bnRoZXNpemUgdGhlIGdpdmVuIHNldCBvZiBzdGFja3MgKGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJ1bnMgJ2NkayBzeW50aCcpXG4gICAqXG4gICAqIElOUFVUOiBTdGFjayBuYW1lcyBjYW4gYmUgc3VwcGxpZWQgdXNpbmcgYSBnbG9iIGZpbHRlci4gSWYgbm8gc3RhY2tzIGFyZVxuICAgKiBnaXZlbiwgYWxsIHN0YWNrcyBmcm9tIHRoZSBhcHBsaWNhdGlvbiBhcmUgaW1wbGljdGx5IHNlbGVjdGVkLlxuICAgKlxuICAgKiBPVVRQVVQ6IElmIG1vcmUgdGhhbiBvbmUgc3RhY2sgZW5kcyB1cCBiZWluZyBzZWxlY3RlZCwgYW4gb3V0cHV0IGRpcmVjdG9yeVxuICAgKiBzaG91bGQgYmUgc3VwcGxpZWQsIHdoZXJlIHRoZSB0ZW1wbGF0ZXMgd2lsbCBiZSB3cml0dGVuLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY2xpU3ludGhlc2l6ZShzdGFja0lkczogc3RyaW5nW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVzaXZlbHk6IGJvb2xlYW4pOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIE9ubHkgYXV0b3NlbGVjdCBkZXBlbmRlbmNpZXMgaWYgaXQgZG9lc24ndCBpbnRlcmZlcmUgd2l0aCB1c2VyIHJlcXVlc3Qgb3Igb3V0cHV0IG9wdGlvbnNcbiAgICBjb25zdCBhdXRvU2VsZWN0RGVwZW5kZW5jaWVzID0gIWV4Y2x1c2l2ZWx5O1xuXG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXBwU3RhY2tzLnNlbGVjdFN0YWNrcyhzdGFja0lkcywge1xuICAgICAgZXh0ZW5kOiBhdXRvU2VsZWN0RGVwZW5kZW5jaWVzID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbSA6IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3NcbiAgICB9KTtcblxuICAgIGFwcFN0YWNrcy5wcm9jZXNzTWV0YWRhdGEoc3RhY2tzKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgc3RhY2ssIHByaW50IGl0IHRvIFNURE9VVFxuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gc3RhY2tzWzBdLnRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYSBzbGlnaHQgaGFjazsgaW4gaW50ZWcgbW9kZSB3ZSBhbGxvdyBtdWx0aXBsZSBzdGFja3MgdG8gYmUgc3ludGhlc2l6ZWQgdG8gc3Rkb3V0IHNlcXVlbnRpYWxseS5cbiAgICAvLyBUaGlzIGlzIHRvIG1ha2UgaXQgc28gdGhhdCB3ZSBjYW4gc3VwcG9ydCBtdWx0aS1zdGFjayBpbnRlZyB0ZXN0IGV4cGVjdGF0aW9ucywgd2l0aG91dCBzbyBkcmFzdGljYWxseVxuICAgIC8vIGhhdmluZyB0byBjaGFuZ2UgdGhlIHN5bnRoZXNpcyBmb3JtYXQgdGhhdCB3ZSBoYXZlIHRvIHJlcnVuIGFsbCBpbnRlZyB0ZXN0cy5cbiAgICAvL1xuICAgIC8vIEJlY2F1c2UgdGhpcyBmZWF0dXJlIGlzIG5vdCB1c2VmdWwgdG8gY29uc3VtZXJzICh0aGUgb3V0cHV0IGlzIG1pc3NpbmdcbiAgICAvLyB0aGUgc3RhY2sgbmFtZXMpLCBpdCdzIG5vdCBleHBvc2VkIGFzIGEgQ0xJIGZsYWcuIEluc3RlYWQsIGl0J3MgaGlkZGVuXG4gICAgLy8gYmVoaW5kIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgIGNvbnN0IGlzSW50ZWdNb2RlID0gcHJvY2Vzcy5lbnYuQ0RLX0lOVEVHX01PREUgPT09ICcxJztcbiAgICBpZiAoaXNJbnRlZ01vZGUpIHtcbiAgICAgIHJldHVybiBzdGFja3MubWFwKHMgPT4gcy50ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gbm90IG91dHB1dHRpbmcgdGVtcGxhdGUgdG8gc3Rkb3V0LCBsZXQncyBleHBsYWluIHRoaW5ncyB0byB0aGUgdXNlciBhIGxpdHRsZSBiaXQuLi5cbiAgICBzdWNjZXNzKGBTdWNjZXNzZnVsbHkgc3ludGhlc2l6ZWQgdG8gJHtjb2xvcnMuYmx1ZShwYXRoLnJlc29sdmUoYXBwU3RhY2tzLmFzc2VtYmx5IS5kaXJlY3RvcnkpKX1gKTtcbiAgICBwcmludChgU3VwcGx5IGEgc3RhY2sgaWQgKCR7c3RhY2tzLm1hcChzID0+IGNvbG9ycy5ncmVlbihzLmlkKSkuam9pbignLCAnKX0pIHRvIGRpc3BsYXkgaXRzIHRlbXBsYXRlLmApO1xuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNsaUxpc3Qoc2VsZWN0b3JzOiBzdHJpbmdbXSwgb3B0aW9uczogeyBsb25nPzogYm9vbGVhbiB9ID0geyB9KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXBwU3RhY2tzLnNlbGVjdFN0YWNrcyhzZWxlY3RvcnMsIHsgZGVmYXVsdEJlaGF2aW9yOiBEZWZhdWx0U2VsZWN0aW9uLkFsbFN0YWNrcyB9KTtcblxuICAgIC8vIGlmIHdlIGFyZSBpbiBcImxvbmdcIiBtb2RlLCBlbWl0IHRoZSBhcnJheSBhcy1pcyAoSlNPTi9ZQU1MKVxuICAgIGlmIChvcHRpb25zLmxvbmcpIHtcbiAgICAgIGNvbnN0IGxvbmcgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxvbmcucHVzaCh7XG4gICAgICAgICAgaWQ6IHN0YWNrLmlkLFxuICAgICAgICAgIG5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICBlbnZpcm9ubWVudDogc3RhY2suZW52aXJvbm1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9uZzsgLy8gd2lsbCBiZSBZQU1MIGZvcm1hdHRlZCBvdXRwdXRcbiAgICB9XG5cbiAgICAvLyBqdXN0IHByaW50IHN0YWNrIElEc1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBkYXRhKHN0YWNrLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDsgLy8gZXhpdC1jb2RlXG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggYSBzaW5nbGUgc3RhY2sgZnJvbSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgc3RhY2tzXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBmaW5kU3RhY2soYXJ0aWZhY3RJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhcHBTdGFja3Muc2VsZWN0U3RhY2tzKFthcnRpZmFjdElkXSwge1xuICAgICAgZXh0ZW5kOiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmUsXG4gICAgICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb24uTm9uZVxuICAgIH0pO1xuXG4gICAgLy8gQ291bGQgaGF2ZSBiZWVuIGEgZ2xvYiBzbyBjaGVjayB0aGF0IHdlIGV2YWx1YXRlZCB0byBleGFjdGx5IG9uZVxuICAgIGlmIChzdGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGNvbW1hbmQgcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RhY2sgYW5kIHdlIG1hdGNoZWQgbW9yZSB0aGFuIG9uZTogJHtzdGFja3MubWFwKHggPT4geC5pZCl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrc1swXS5pZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSnNvbk9yWWFtbChvYmplY3Q6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVN0cnVjdHVyZShvYmplY3QsIGFyZ3YuanNvbik7XG4gIH1cbn1cblxuaW5pdENvbW1hbmRMaW5lKClcbiAgLnRoZW4odmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCh2YWx1ZSk7XG4gICAgfVxuICB9KVxuICAuY2F0Y2goZXJyID0+IHtcbiAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgZGVidWcoZXJyLnN0YWNrKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH0pO1xuIl19